---
title: テスト間でのデータベースの共有-EF Core
description: 複数のテスト間でデータベースを共有する方法を示すサンプル
author: ajcvickers
ms.date: 04/25/2020
uid: core/testing/sharing-databases
ms.openlocfilehash: 7a90a144271d5c34e9d5043aa439f84db805c6af
ms.sourcegitcommit: 032a1767d7a6e42052a005f660b80372c6521e7e
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/12/2021
ms.locfileid: "98128837"
---
# <a name="sharing-databases-between-tests"></a>テスト間でのデータベースの共有

[EF Core テストのサンプル](xref:core/testing/testing-sample)では、さまざまなデータベースシステムに対してアプリケーションをテストする方法を示しました。
このサンプルでは、各テストで新しいデータベースが作成されています。
SQLite または EF のメモリ内データベースを使用する場合は、このパターンが適していますが、他のデータベースシステムを使用する場合はかなりのオーバーヘッドが発生する可能性があります。

このサンプルは、データベースの作成をテストフィクスチャに移行することによって、前のサンプルに基づいています。
これにより、1つの SQL Server データベースを作成し、すべてのテストに1回だけシードすることができます。

> [!TIP]
> ここで続行する前に、 [EF Core テストのサンプル](xref:core/testing/testing-sample) を使用するようにしてください。

同じデータベースに対して複数のテストを記述するのは困難です。
この方法では、テストを実行するたびにテストが行われないようにします。
次のことを理解する必要があります。

* テスト間でオブジェクトを安全に共有する方法
* テストフレームワークが並列でテストを実行する場合
* すべてのテストでデータベースをクリーンな状態に保つ方法

## <a name="the-fixture"></a>フィクスチャ

テスト間でオブジェクトを共有するためのテストフィクスチャを使用します。
[Xunit ドキュメント](https://xunit.net/docs/shared-context.html)では、1つのテストコンテキストを作成し、クラス内のすべてのテスト間で共有する場合に、クラス内のすべてのテストが終了した後に、フィクスチャを使用する必要があることを示しています。

> [!TIP]
> このサンプルでは [Xunit](https://xunit.net/)を使用しますが、 [NUnit](https://nunit.org/)などの他のテストフレームワークにも同様の概念があります。

これは、データベースの作成とシード処理をフィクスチャクラスに移動する必要があることを意味します。
次のように表示されます。

[!code-csharp[SharedDatabaseFixture](../../../samples/core/Miscellaneous/Testing/ItemsWebApi/SharedDatabaseTests/SharedDatabaseFixture.cs?name=SharedDatabaseFixture)]

ここでは、コンストラクターのしくみに注意してください。

* フィクスチャの有効期間中、単一のデータベース接続を作成します。
* メソッドを呼び出してそのデータベースを作成し、シードします。 `Seed`

ここではロックを無視します。これについては後で説明します。

> [!TIP]
> 作成およびシード処理のコードは非同期である必要はありません。
> 非同期にすると、コードが複雑になり、テストのパフォーマンスやスループットが向上することはありません。

データベースを作成するには、まず既存のデータベースを削除してから、新しいデータベースを作成します。
これにより、前回のテストの実行後にデータベースが変更されていても、データベースが現在の EF モデルと一致するようになります。

> [!TIP]
> 既存のデータベースを再作成するので [はなく、](https://jimmybogard.com/tag/respawn/) 再作成するのではなく、簡単に "クリーンアップ" できます。
> ただし、この操作を行うときは、EF モデルを使用してデータベーススキーマを最新の状態に保つ必要があります。

データベース接続は、フィクスチャが破棄されると破棄されます。
この時点で、テストデータベースの削除を検討することもできます。
ただし、フィクスチャが複数のテストクラスで共有されている場合は、追加のロックと参照カウントが必要になります。
また、多くの場合、失敗したテストをデバッグするためにテストデータベースを使用できるようにすると便利です。

## <a name="using-the-fixture"></a>フィクスチャの使用

XUnit には、テストフィクスチャをテストのクラスに関連付けるための一般的なパターンがあります。

[!code-csharp[UsingTheFixture](../../../samples/core/Miscellaneous/Testing/ItemsWebApi/SharedDatabaseTests/SharedDatabaseTest.cs?name=UsingTheFixture)]

これで、XUnit が1つのフィクスチャインスタンスを作成し、テストクラスの各インスタンスに渡します。
(最初のテストの [例](xref:core/testing/testing-sample) では、xunit がテストを実行するたびに新しいテストクラスのインスタンスを作成することに注意してください)。これは、データベースが作成され、1回シードされると、各テストでこのデータベースが使用されることを意味します。

1つのクラス内のテストは並行して実行されないことに注意してください。
つまり、 `DbConnection` オブジェクトがスレッドセーフではない場合でも、各テストで同じデータベース接続を使用するのが安全です。

## <a name="maintaining-database-state"></a>データベースの状態の維持

テストでは、多くの場合、挿入、更新、および削除を使用してテストデータを変更する必要があります。
ただし、これらの変更は、クリーンなシード処理されたデータベースを想定している他のテストに影響を与えます。

これは、トランザクション内で変更テストを実行することで処理できます。
例:

[!code-csharp[CanAddItem](../../../samples/core/Miscellaneous/Testing/ItemsWebApi/SharedDatabaseTests/SharedDatabaseTest.cs?name=CanAddItem)]

テストが開始され、完了時に破棄されると、トランザクションが作成されることに注意してください。
トランザクションを破棄すると、トランザクションがロールバックされます。そのため、他のテストによって変更が表示されることはありません。

コンテキストを作成するためのヘルパーメソッド (上記のフィクスチャコードを参照) は、このトランザクションを受け入れ、それを使用するように DbContext を指定します。

## <a name="sharing-the-fixture"></a>フィクスチャの共有

データベースの作成とシード処理に関するコードをロックしている可能性があります。
このサンプルではこの方法は必要ありません。これは、テストの1つのクラスのみがフィクスチャを使用するためです。そのため、フィクスチャインスタンスは1つだけ作成されます。

ただし、複数のクラスのテストで同じフィクスチャを使用することもできます。
XUnit は、これらのクラスごとに1つのフィクスチャインスタンスを作成します。
これらは、テストを並列で実行するさまざまなスレッドによって使用される場合があります。
したがって、データベースの作成とシード処理を行うスレッドが1つだけになるように、適切なロックを設定することが重要です。

> [!TIP]
> `lock`ここでは簡単です。
> ロックフリーのパターンなど、複雑な操作を行う必要はありません。
