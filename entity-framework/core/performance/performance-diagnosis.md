---
title: パフォーマンスの診断-EF Core
description: Entity Framework Core パフォーマンスの診断とボトルネックの特定
author: roji
ms.date: 12/1/2020
uid: core/performance/performance-diagnosis
ms.openlocfilehash: 9416acf3326056ef7a5d732c4bd456dac751167b
ms.sourcegitcommit: 4860d036ea0fb392c28799907bcc924c987d2d7b
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/17/2020
ms.locfileid: "97657721"
---
# <a name="performance-diagnosis"></a><span data-ttu-id="2db64-103">パフォーマンス診断</span><span class="sxs-lookup"><span data-stu-id="2db64-103">Performance Diagnosis</span></span>

<span data-ttu-id="2db64-104">このセクションでは、EF アプリケーションでパフォーマンスの問題を検出する方法について説明します。問題のある領域が特定されたら、それらをさらに分析して根本的な問題を特定する方法についても説明します。</span><span class="sxs-lookup"><span data-stu-id="2db64-104">This section discusses ways for detecting performance issues in your EF application, and once a problematic area has been identified, how to further analyze them to identify the root problem.</span></span> <span data-ttu-id="2db64-105">問題を注意深く診断して調査してから結論にジャンプし、問題の根本点を想定しないようにすることが重要です。</span><span class="sxs-lookup"><span data-stu-id="2db64-105">It's important to carefully diagnose and investigate any problems before jumping to any conclusions, and to avoid assuming where the root of the issue is.</span></span>

## <a name="identifying-slow-database-commands-via-logging"></a><span data-ttu-id="2db64-106">ログ記録による低速データベースコマンドの識別</span><span class="sxs-lookup"><span data-stu-id="2db64-106">Identifying slow database commands via logging</span></span>

<span data-ttu-id="2db64-107">1日の終わりに、EF はデータベースに対して実行するコマンドを準備して実行します。リレーショナルデータベースでは、ADO.NET database API を使用して SQL ステートメントを実行します。</span><span class="sxs-lookup"><span data-stu-id="2db64-107">At the end of the day, EF prepares and executes commands to be executed against your database; with relational database, that means executing SQL statements via the ADO.NET database API.</span></span> <span data-ttu-id="2db64-108">特定のクエリの実行に時間がかかりすぎる場合 (インデックスが不足している場合など)、コマンド実行ログを調べ、実際にかかった時間を観察することで、このことが検出される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="2db64-108">If a certain query is taking too much time (e.g. because an index is missing), this can be seen discovered by inspecting command execution logs and observing how long they actually take.</span></span>

<span data-ttu-id="2db64-109">EF を使用すると、 [単純なログ](xref:core/logging-events-diagnostics/simple-logging) 記録または [拡張機能](xref:core/logging-events-diagnostics/extensions-logging)を使用して、コマンドの実行時間を簡単にキャプチャできます。</span><span class="sxs-lookup"><span data-stu-id="2db64-109">EF makes it very easy to capture command execution times, via either [simple logging](xref:core/logging-events-diagnostics/simple-logging) or [Microsoft.Extensions.Logging](xref:core/logging-events-diagnostics/extensions-logging):</span></span>

### <a name="simple-logging"></a>[<span data-ttu-id="2db64-110">シンプルなログ</span><span class="sxs-lookup"><span data-stu-id="2db64-110">Simple logging</span></span>](#tab/simple-logging)

[!code-csharp[Main](../../../samples/core/Performance/BloggingContext.cs#SimpleLogging)]

### <a name="microsoftextensionslogging"></a>[<span data-ttu-id="2db64-111">Microsoft.Extensions.Logging</span><span class="sxs-lookup"><span data-stu-id="2db64-111">Microsoft.Extensions.Logging</span></span>](#tab/microsoft-extensions-logging)

[!code-csharp[Main](../../../samples/core/Performance/ExtensionsLoggingContext.cs#ExtensionsLogging)]

***

<span data-ttu-id="2db64-112">ログ記録レベルがに設定されている場合 `LogLevel.Information` 、EF は、コマンドの実行ごとにログメッセージを出力します。</span><span class="sxs-lookup"><span data-stu-id="2db64-112">When the logging level is set at `LogLevel.Information`, EF emits a log message for each command execution with the time taken:</span></span>

```log
info: 06/12/2020 09:12:36.117 RelationalEventId.CommandExecuted[20101] (Microsoft.EntityFrameworkCore.Database.Command)
      Executed DbCommand (4ms) [Parameters=[], CommandType='Text', CommandTimeout='30']
      SELECT [b].[Id], [b].[Name]
      FROM [Blogs] AS [b]
      WHERE [b].[Name] = N'foo'
```

<span data-ttu-id="2db64-113">上記のコマンドでは、4ミリ秒かかりました。</span><span class="sxs-lookup"><span data-stu-id="2db64-113">The above command took 4 milliseconds.</span></span> <span data-ttu-id="2db64-114">特定のコマンドの実行に予想以上の時間がかかる場合は、パフォーマンスの問題の原因が考えられ、それに焦点を当てることで、パフォーマンスの低下の原因を把握できるようになりました。</span><span class="sxs-lookup"><span data-stu-id="2db64-114">If a certain command takes more than expected, you've found a possible culprit for a performance issue, and can now focus on it to understand why it's running slowly.</span></span> <span data-ttu-id="2db64-115">コマンドログを使用すると、予期しないデータベースのラウンドトリップが行われているケースを明らかにすることもできます。これは、1つだけが必要な複数のコマンドとして表示されます。</span><span class="sxs-lookup"><span data-stu-id="2db64-115">Command logging can also reveal cases where unexpected database roundtrips are being made; this would show up as multiple commands where only one is expected.</span></span>

> [!WARNING]
> <span data-ttu-id="2db64-116">実稼働環境でコマンド実行ログを有効にしたままにすることは、通常は正しくありません。</span><span class="sxs-lookup"><span data-stu-id="2db64-116">Leaving command execution logging enabled in your production environment is usually a bad idea.</span></span> <span data-ttu-id="2db64-117">ログ自体によってアプリケーションの速度が低下し、サーバーのディスクにいっぱいになる大きなログファイルをすばやく作成できます。</span><span class="sxs-lookup"><span data-stu-id="2db64-117">The logging itself slows down your application, and may quickly create huge log files which can fill up your server's disk.</span></span> <span data-ttu-id="2db64-118">アプリケーションを慎重に監視しながら、または実稼働前システムのログデータをキャプチャするために、短時間でログ記録を保持することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="2db64-118">It's recommended to only keep logging on for a short interval of time to gather data - while carefully monitoring your application - or to capture logging data on a pre-production system.</span></span>

## <a name="correlating-database-commands-to-linq-queries"></a><span data-ttu-id="2db64-119">LINQ クエリへのデータベースコマンドの関連付け</span><span class="sxs-lookup"><span data-stu-id="2db64-119">Correlating database commands to LINQ queries</span></span>

<span data-ttu-id="2db64-120">コマンド実行ログの問題の1つとして、SQL クエリと LINQ クエリを関連付けることが困難な場合があります。 EF によって実行される SQL コマンドは、生成元の LINQ クエリと大きく異なる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="2db64-120">One problem with command execution logging is that it's sometimes difficult to correlate SQL queries and LINQ queries: the SQL commands executed by EF can look very different from the LINQ queries from which they were generated.</span></span> <span data-ttu-id="2db64-121">この問題を解決するには、EF の [クエリタグ](xref:core/querying/tags) 機能を使用します。これにより、SQL クエリに小さな識別コメントを挿入できます。</span><span class="sxs-lookup"><span data-stu-id="2db64-121">To help with this difficulty, you may want to use EF's [query tags](xref:core/querying/tags) feature, which allows you to inject a small, identifying comment into the SQL query:</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tags/Program.cs#BasicQueryTag)]

<span data-ttu-id="2db64-122">タグがログに表示されます。</span><span class="sxs-lookup"><span data-stu-id="2db64-122">The tag shows up in the logs:</span></span>

```sql
-- This is my spatial query!

SELECT TOP(@__p_1) [p].[Id], [p].[Location]
FROM [People] AS [p]
ORDER BY [p].[Location].STDistance(@__myLocation_0) DESC
```

<span data-ttu-id="2db64-123">多くの場合、この方法でアプリケーションの主要なクエリにタグを付けて、コマンドの実行ログをすぐに読み取ることができるようにします。</span><span class="sxs-lookup"><span data-stu-id="2db64-123">It's often worth tagging the major queries of an application in this way, to make the command execution logs more immediately readable.</span></span>

## <a name="other-interfaces-for-capturing-performance-data"></a><span data-ttu-id="2db64-124">パフォーマンスデータをキャプチャするためのその他のインターフェイス</span><span class="sxs-lookup"><span data-stu-id="2db64-124">Other interfaces for capturing performance data</span></span>

<span data-ttu-id="2db64-125">EF のログ記録機能には、コマンドの実行時間をキャプチャするためのさまざまな選択肢があります。これは、より強力です。</span><span class="sxs-lookup"><span data-stu-id="2db64-125">There are various alternatives to EF's logging feature for capturing command execution times, which may be more powerful.</span></span> <span data-ttu-id="2db64-126">データベースには、通常、独自のトレースおよびパフォーマンス分析ツールが付属しています。これらのツールは、通常、単純な実行時間を超えて、より豊富でデータベース固有の情報を提供します。実際のセットアップ、機能、使用状況は、データベースによって大きく異なります。</span><span class="sxs-lookup"><span data-stu-id="2db64-126">Databases typically come with their own tracing and performance analysis tools, which usually provide much richer, database-specific information beyond simple execution times; the actual setup, capabilities and usage vary considerably across databases.</span></span>

<span data-ttu-id="2db64-127">たとえば、 [SQL Server Management Studio](/sql/ssms/download-sql-server-management-studio-ssms) は、SQL Server インスタンスに接続し、重要な管理とパフォーマンスの情報を提供できる強力なクライアントです。</span><span class="sxs-lookup"><span data-stu-id="2db64-127">For example, [SQL Server Management Studio](/sql/ssms/download-sql-server-management-studio-ssms) is a powerful client that can connect to your SQL Server  instance and provide valuable management and performance information.</span></span> <span data-ttu-id="2db64-128">詳細については、このセクションでは説明しませんが、注意が必要な2つの機能は、サーバーアクティビティのライブダッシュボード (最もコストの高いクエリを含む) と[拡張イベント (XEvent)](/sql/relational-databases/extended-events/quick-start-extended-events-in-sql-server)機能を提供する[利用状況モニター](/sql/relational-databases/performance-monitor/open-activity-monitor-sql-server-management-studio)です。これにより、正確なニーズに合わせて調整できる任意のデータキャプチャセッションを定義できます。</span><span class="sxs-lookup"><span data-stu-id="2db64-128">It's beyond the scope of this section to go into the details, but two capabilities worth mentioning are the [Activity Monitor](/sql/relational-databases/performance-monitor/open-activity-monitor-sql-server-management-studio), which provides a live dashboard of server activity (including the most expensive queries), and the [Extended Events (XEvent)](/sql/relational-databases/extended-events/quick-start-extended-events-in-sql-server) feature, which allows defining arbitrary data capture sessions which can be tailored to your exact needs.</span></span> <span data-ttu-id="2db64-129">[監視に関する SQL Server のドキュメント](/sql/relational-databases/performance/monitor-and-tune-for-performance) では、これらの機能に加え、他の機能についても詳しく説明しています。</span><span class="sxs-lookup"><span data-stu-id="2db64-129">[The SQL Server documentation on monitoring](/sql/relational-databases/performance/monitor-and-tune-for-performance) provides more information on these features, as well as others.</span></span>

<span data-ttu-id="2db64-130">パフォーマンスデータをキャプチャするもう1つの方法は、EF またはデータベースドライバーによって自動的に生成された情報をインターフェイス経由で収集 `DiagnosticSource` し、そのデータを分析してダッシュボードに表示することです。</span><span class="sxs-lookup"><span data-stu-id="2db64-130">Another approach for capturing performance data is to collect information automatically emitted by either EF or the database driver via the `DiagnosticSource` interface, and then analyze that data or display it on a dashboard.</span></span> <span data-ttu-id="2db64-131">Azure を使用している場合、 [Azure アプリケーション Insights](https://docs.microsoft.com/azure/azure-monitor/learn/tutorial-performance) では、このような強力な監視機能がすぐに利用可能になり、web 要求の処理速度の分析において、データベースのパフォーマンスとクエリの実行時間が統合されます。</span><span class="sxs-lookup"><span data-stu-id="2db64-131">If you are using Azure, then [Azure Application Insights](https://docs.microsoft.com/azure/azure-monitor/learn/tutorial-performance) provides such powerful monitoring out of the box, integrating database performance and query execution times in the analysis of how quickly your web requests are being served.</span></span> <span data-ttu-id="2db64-132">詳細については、 [Application Insights パフォーマンスのチュートリアル](/azure/azure-monitor/learn/tutorial-performance)と [Azure SQL analytics のページ](/azure/azure-monitor/insights/azure-sql)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="2db64-132">More information on this is available in the [Application Insights performance tutorial](/azure/azure-monitor/learn/tutorial-performance), and in the [Azure SQL analytics page](/azure/azure-monitor/insights/azure-sql).</span></span>

## <a name="inspecting-query-execution-plans"></a><span data-ttu-id="2db64-133">クエリ実行プランの検査</span><span class="sxs-lookup"><span data-stu-id="2db64-133">Inspecting query execution plans</span></span>

<span data-ttu-id="2db64-134">最適化が必要な問題のあるクエリを特定したら、通常はクエリの *実行プラン* を分析します。</span><span class="sxs-lookup"><span data-stu-id="2db64-134">Once you've pinpointed a problematic query that requires optimization, the next step is usually analyzing the query's *execution plan*.</span></span> <span data-ttu-id="2db64-135">データベースが SQL ステートメントを受け取ると、通常、そのプランの実行方法のプランが生成されます。これには、インデックスが定義されているかどうか、テーブルにどのくらいのデータが存在するかに基づいて、複雑な意思決定が必要になることがあります (ちなみに、最適なパフォーマンスを実現するために、通常はサーバーでプランそのものをキャッシュする必要があります)。</span><span class="sxs-lookup"><span data-stu-id="2db64-135">When databases receive a SQL statement, they typically produce a plan of how that plan is to be executed; this sometimes requires complicated decision-making based on which indexes have been defined, how much data exists in tables, etc. (incidentally, the plan itself should usually be cached at the server for optimal performance).</span></span> <span data-ttu-id="2db64-136">通常、リレーショナルデータベースは、クエリのさまざまな部分に対して計算されたコストと共に、ユーザーがクエリプランを表示する方法を提供します。これは、クエリを改善するために非常に重要です。</span><span class="sxs-lookup"><span data-stu-id="2db64-136">Relational databases typically provide a way for users to see the query plan, along with calculated costing for different parts of the query; this is invaluable for improving your queries.</span></span>

<span data-ttu-id="2db64-137">SQL Server の概要については、 [クエリ実行プラン](/sql/relational-databases/performance/execution-plans)に関するドキュメントを参照してください。</span><span class="sxs-lookup"><span data-stu-id="2db64-137">To get started on SQL Server, see the documentation on [query execution plans](/sql/relational-databases/performance/execution-plans).</span></span> <span data-ttu-id="2db64-138">一般的な分析ワークフローでは、 [SQL Server Management Studio](/sql/relational-databases/performance/display-an-actual-execution-plan)を使用し、上記のいずれかの方法で特定された低速クエリの SQL を貼り付け、 [グラフィカルな実行プランを生成](/sql/relational-databases/performance/display-an-actual-execution-plan)します。</span><span class="sxs-lookup"><span data-stu-id="2db64-138">The typical analysis workflow would be to use [SQL Server Management Studio](/sql/relational-databases/performance/display-an-actual-execution-plan), pasting the SQL of a slow query identified via one of the means above, and [producing a graphical execution plan](/sql/relational-databases/performance/display-an-actual-execution-plan):</span></span>

![SQL Server 実行プランを表示する](_static/actualexecplan.png)

<span data-ttu-id="2db64-140">実行プランは一見複雑に思えるかもしれませんが、理解を深めるには少し時間がかかります。</span><span class="sxs-lookup"><span data-stu-id="2db64-140">While execution plans may seem complicated at first, it's worth spending a bit of time getting familiar with them.</span></span> <span data-ttu-id="2db64-141">特に重要なのは、プランの各ノードに関連付けられているコストを書き留め、さまざまなノードでインデックスがどのように使用されているか (またはない) を特定することです。</span><span class="sxs-lookup"><span data-stu-id="2db64-141">It's particularly important to note the costs associated with each node of the plan, and to identify how indexes are used (or not) in the various nodes.</span></span>

<span data-ttu-id="2db64-142">上記の情報は SQL Server に固有のものですが、他のデータベースでは通常、同様の視覚エフェクトを持つ同じ種類のツールが提供されます。</span><span class="sxs-lookup"><span data-stu-id="2db64-142">While the above information is specific to SQL Server, other databases typically provide the same kind of tools with similar visualization.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="2db64-143">データベースでは、データベース内の実際のデータに応じて異なるクエリプランが生成されることがあります。</span><span class="sxs-lookup"><span data-stu-id="2db64-143">Databases sometimes generate different query plans depending on actual data in the database.</span></span> <span data-ttu-id="2db64-144">たとえば、テーブルに少数の行しか含まれていない場合、データベースはそのテーブルのインデックスを使用しないことを選択できますが、フルテーブルスキャンを実行するように選択できます。</span><span class="sxs-lookup"><span data-stu-id="2db64-144">For example, if a table contains only a few rows, a database may choose not to use an index on that table, but to perform a full table scan instead.</span></span> <span data-ttu-id="2db64-145">テストデータベースでクエリプランを分析する場合は、実稼働システムと同様のデータが含まれていることを必ず確認してください。</span><span class="sxs-lookup"><span data-stu-id="2db64-145">If analyzing query plans on a test database, always make sure it contains data that is similar to your production system.</span></span>

## <a name="event-counters"></a><span data-ttu-id="2db64-146">イベント カウンター</span><span class="sxs-lookup"><span data-stu-id="2db64-146">Event counters</span></span>

<span data-ttu-id="2db64-147">上記のセクションでは、コマンドに関する情報を取得する方法と、これらのコマンドをデータベースで実行する方法に重点を置いています。</span><span class="sxs-lookup"><span data-stu-id="2db64-147">The above sections focused on how to get information about your commands, and how these commands are executed in the database.</span></span> <span data-ttu-id="2db64-148">さらに、EF では、EF 自体の内部で起きていることと、アプリケーションでどのように使用されているかについて、より低いレベルの情報を提供する一連の *イベントカウンター* を公開しています。</span><span class="sxs-lookup"><span data-stu-id="2db64-148">In addition to that, EF exposes a set of *event counters* which provide more lower-level information on what's happening inside EF itself, and how your application is using it.</span></span> <span data-ttu-id="2db64-149">これらのカウンターは、特定のパフォーマンスの問題とパフォーマンスの異常を診断するのに非常に役立ちます。たとえば、定数の再コンパイルや、破棄されていない DbContext リークなどを引き起こす [クエリキャッシュの問題](xref:core/performance/advanced-performance-topics#dynamically-constructed-queries) などです。</span><span class="sxs-lookup"><span data-stu-id="2db64-149">These counters can be very useful for diagnosing specific performance issues and performance anomalies, such as [query caching issues](xref:core/performance/advanced-performance-topics#dynamically-constructed-queries) which cause constant recompilation, undisposed DbContext leaks, and others.</span></span>

<span data-ttu-id="2db64-150">詳細については、 [EF のイベントカウンター](xref:core/logging-events-diagnostics/event-counters) の専用ページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="2db64-150">See the dedicated page on [EF's event counters](xref:core/logging-events-diagnostics/event-counters) for more information.</span></span>

## <a name="benchmarking-with-ef-core"></a><span data-ttu-id="2db64-151">EF Core を使用したベンチマーク</span><span class="sxs-lookup"><span data-stu-id="2db64-151">Benchmarking with EF Core</span></span>

<span data-ttu-id="2db64-152">1日の終わりに、クエリの書き込みまたは実行の特定の方法が他より高速であるかどうかを知る必要がある場合があります。</span><span class="sxs-lookup"><span data-stu-id="2db64-152">At the end of the day, you sometimes need to know whether a particular way of writing or executing a query is faster than another.</span></span> <span data-ttu-id="2db64-153">回答を想定したり speculate したりすることは決して重要ではありません。答えを得るためのクイックベンチマークを非常に簡単にまとめることができます。</span><span class="sxs-lookup"><span data-stu-id="2db64-153">It's important to never assume or speculate the answer, and it's extremely easy to put together a quick benchmark to get the answer.</span></span> <span data-ttu-id="2db64-154">ベンチマークを作成する場合は、よく知られた [BenchmarkDotNet](https://benchmarkdotnet.org/index.html) ライブラリを使用することを強くお勧めします。これは、ユーザーが独自のベンチマークを作成するときに発生する多くの落とし穴を処理します。ウォームアップイテレーションをいくつか実行したことを確認できます。</span><span class="sxs-lookup"><span data-stu-id="2db64-154">When writing benchmarks, it's strongly recommended to use the well-known [BenchmarkDotNet](https://benchmarkdotnet.org/index.html) library, which handles many pitfalls users encounter when trying to write their own benchmarks: have you performed some warmup iterations?</span></span> <span data-ttu-id="2db64-155">ベンチマークの実際の実行回数と、その理由</span><span class="sxs-lookup"><span data-stu-id="2db64-155">How many iterations does your benchmark actually run, and why?</span></span> <span data-ttu-id="2db64-156">EF Core のベンチマークの外観を見てみましょう。</span><span class="sxs-lookup"><span data-stu-id="2db64-156">Let's take a look at what a benchmark with EF Core looks like.</span></span>

> [!TIP]
> <span data-ttu-id="2db64-157">以下のソースの完全なベンチマークプロジェクトは、 [こちら](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/AverageBlogRanking.cs)から入手できます。</span><span class="sxs-lookup"><span data-stu-id="2db64-157">The full benchmark project for the source below is available [here](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/AverageBlogRanking.cs).</span></span> <span data-ttu-id="2db64-158">これをコピーして、独自のベンチマークのテンプレートとして使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="2db64-158">You are encouraged to copy it and use it as a template for your own benchmarks.</span></span>

<span data-ttu-id="2db64-159">単純なベンチマークシナリオとして、データベース内のすべてのブログの平均順位を計算する次のような方法を比較してみましょう。</span><span class="sxs-lookup"><span data-stu-id="2db64-159">As a simple benchmark scenario, let's compare the following different methods of calculating the average ranking of all Blogs in our database:</span></span>

* <span data-ttu-id="2db64-160">すべてのエンティティを読み込んで、個々のランキングを合計し、平均を計算します。</span><span class="sxs-lookup"><span data-stu-id="2db64-160">Load all entities, sum up their individual rankings, and calculate the average.</span></span>
* <span data-ttu-id="2db64-161">上記と同じですが、非追跡クエリのみを使用します。</span><span class="sxs-lookup"><span data-stu-id="2db64-161">The same as above, only use a non-tracking query.</span></span> <span data-ttu-id="2db64-162">Id の解決は実行されず、エンティティが変更の追跡の目的でスナップショットを使用していないため、この処理がより高速になります。</span><span class="sxs-lookup"><span data-stu-id="2db64-162">This should be faster, since identity resolution isn't performed, and the entities aren't snapshotted for the purposes of change tracking.</span></span>
* <span data-ttu-id="2db64-163">順位付けのみを射影することにより、ブログエンティティインスタンス全体をまったく読み込まないようにします。</span><span class="sxs-lookup"><span data-stu-id="2db64-163">Avoid loading the entire Blog entity instances at all, by projecting out the ranking only.</span></span> <span data-ttu-id="2db64-164">によって、ブログエンティティ型の他の不要な列が転送されるのを防ぐことができます。</span><span class="sxs-lookup"><span data-stu-id="2db64-164">The saves us from transferring the other, unneeded columns of the Blog entity type.</span></span>
* <span data-ttu-id="2db64-165">クエリの一部にすることで、データベース内の平均を計算します。</span><span class="sxs-lookup"><span data-stu-id="2db64-165">Calculate the average in the database by making it part of the query.</span></span> <span data-ttu-id="2db64-166">すべてがデータベースで計算され、結果だけがクライアントに返されるため、これは最速の方法です。</span><span class="sxs-lookup"><span data-stu-id="2db64-166">This should be the fastest way, since everything is calculated in the database and only the result is transferred back to the client.</span></span>

<span data-ttu-id="2db64-167">BenchmarkDotNet では、単純なメソッドとしてアプリケーションとしてコードを記述します。単体テストと BenchmarkDotNet では、各メソッドが十分な反復回数だけ自動的に実行され、どれだけの時間とメモリが割り当てられるかが確実に測定されます。</span><span class="sxs-lookup"><span data-stu-id="2db64-167">With BenchmarkDotNet, you write the code to be benchmarked as a simple method - just like a unit test - and BenchmarkDotNet automatically runs each method for sufficient number of iterations, reliably measuring how long it takes and how much memory is allocated.</span></span> <span data-ttu-id="2db64-168">さまざまな方法を次に示します ([完全なベンチマークコードをここで見ることができ](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/AverageBlogRanking.cs)ます)。</span><span class="sxs-lookup"><span data-stu-id="2db64-168">Here are the different method ([the full benchmark code can be seen here](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/AverageBlogRanking.cs)):</span></span>

### <a name="load-entities"></a>[<span data-ttu-id="2db64-169">エンティティの読み込み</span><span class="sxs-lookup"><span data-stu-id="2db64-169">Load entities</span></span>](#tab/load-entities)

[!code-csharp[Main](../../../samples/core/Benchmarks/AverageBlogRanking.cs?name=LoadEntities)]

### <a name="load-entities-no-tracking"></a>[<span data-ttu-id="2db64-170">エンティティの読み込み、追跡なし</span><span class="sxs-lookup"><span data-stu-id="2db64-170">Load entities, no tracking</span></span>](#tab/load-entities-no-tracking)

[!code-csharp[Main](../../../samples/core/Benchmarks/AverageBlogRanking.cs?name=LoadEntitiesNoTracking)]

### <a name="project-only-ranking"></a>[<span data-ttu-id="2db64-171">プロジェクトのみの順位付け</span><span class="sxs-lookup"><span data-stu-id="2db64-171">Project only ranking</span></span>](#tab/project-only-ranking)

[!code-csharp[Main](../../../samples/core/Benchmarks/AverageBlogRanking.cs?name=ProjectOnlyRanking)]

### <a name="calculate-in-database"></a>[<span data-ttu-id="2db64-172">データベースで計算</span><span class="sxs-lookup"><span data-stu-id="2db64-172">Calculate in database</span></span>](#tab/calculate-in-database)

[!code-csharp[Main](../../../samples/core/Benchmarks/AverageBlogRanking.cs?name=CalculateInDatabase)]

***

<span data-ttu-id="2db64-173">BenchmarkDotNet によって出力された結果は次のようになります。</span><span class="sxs-lookup"><span data-stu-id="2db64-173">The results are below, as printed by BenchmarkDotNet:</span></span>

|                 <span data-ttu-id="2db64-174">Method</span><span class="sxs-lookup"><span data-stu-id="2db64-174">Method</span></span> |       <span data-ttu-id="2db64-175">平均</span><span class="sxs-lookup"><span data-stu-id="2db64-175">Mean</span></span> |    <span data-ttu-id="2db64-176">エラー</span><span class="sxs-lookup"><span data-stu-id="2db64-176">Error</span></span> |   <span data-ttu-id="2db64-177">StdDev</span><span class="sxs-lookup"><span data-stu-id="2db64-177">StdDev</span></span> |     <span data-ttu-id="2db64-178">中央値</span><span class="sxs-lookup"><span data-stu-id="2db64-178">Median</span></span> | <span data-ttu-id="2db64-179">比率</span><span class="sxs-lookup"><span data-stu-id="2db64-179">Ratio</span></span> | <span data-ttu-id="2db64-180">RatioSD</span><span class="sxs-lookup"><span data-stu-id="2db64-180">RatioSD</span></span> |    <span data-ttu-id="2db64-181">Gen 0</span><span class="sxs-lookup"><span data-stu-id="2db64-181">Gen 0</span></span> |   <span data-ttu-id="2db64-182">Gen 1</span><span class="sxs-lookup"><span data-stu-id="2db64-182">Gen 1</span></span> | <span data-ttu-id="2db64-183">Gen 2</span><span class="sxs-lookup"><span data-stu-id="2db64-183">Gen 2</span></span> |  <span data-ttu-id="2db64-184">Allocated</span><span class="sxs-lookup"><span data-stu-id="2db64-184">Allocated</span></span> |
|----------------------- |-----------:|---------:|---------:|-----------:|------:|--------:|---------:|--------:|------:|-----------:|
|           <span data-ttu-id="2db64-185">LoadEntities</span><span class="sxs-lookup"><span data-stu-id="2db64-185">LoadEntities</span></span> | <span data-ttu-id="2db64-186">2860.4 us</span><span class="sxs-lookup"><span data-stu-id="2db64-186">2,860.4 us</span></span> | <span data-ttu-id="2db64-187">54.31 us</span><span class="sxs-lookup"><span data-stu-id="2db64-187">54.31 us</span></span> | <span data-ttu-id="2db64-188">93.68 us</span><span class="sxs-lookup"><span data-stu-id="2db64-188">93.68 us</span></span> | <span data-ttu-id="2db64-189">2844.5 us</span><span class="sxs-lookup"><span data-stu-id="2db64-189">2,844.5 us</span></span> |  <span data-ttu-id="2db64-190">4.55</span><span class="sxs-lookup"><span data-stu-id="2db64-190">4.55</span></span> |    <span data-ttu-id="2db64-191">0.33</span><span class="sxs-lookup"><span data-stu-id="2db64-191">0.33</span></span> | <span data-ttu-id="2db64-192">210.9375</span><span class="sxs-lookup"><span data-stu-id="2db64-192">210.9375</span></span> | <span data-ttu-id="2db64-193">70.3125</span><span class="sxs-lookup"><span data-stu-id="2db64-193">70.3125</span></span> |     - | <span data-ttu-id="2db64-194">1309.56 KB</span><span class="sxs-lookup"><span data-stu-id="2db64-194">1309.56 KB</span></span> |
| <span data-ttu-id="2db64-195">LoadEntitiesNoTracking</span><span class="sxs-lookup"><span data-stu-id="2db64-195">LoadEntitiesNoTracking</span></span> | <span data-ttu-id="2db64-196">1353.0 us</span><span class="sxs-lookup"><span data-stu-id="2db64-196">1,353.0 us</span></span> | <span data-ttu-id="2db64-197">21.26 us</span><span class="sxs-lookup"><span data-stu-id="2db64-197">21.26 us</span></span> | <span data-ttu-id="2db64-198">18.85 us</span><span class="sxs-lookup"><span data-stu-id="2db64-198">18.85 us</span></span> | <span data-ttu-id="2db64-199">1355.6 us</span><span class="sxs-lookup"><span data-stu-id="2db64-199">1,355.6 us</span></span> |  <span data-ttu-id="2db64-200">2.10</span><span class="sxs-lookup"><span data-stu-id="2db64-200">2.10</span></span> |    <span data-ttu-id="2db64-201">0.14</span><span class="sxs-lookup"><span data-stu-id="2db64-201">0.14</span></span> |  <span data-ttu-id="2db64-202">87.8906</span><span class="sxs-lookup"><span data-stu-id="2db64-202">87.8906</span></span> |  <span data-ttu-id="2db64-203">3.9063</span><span class="sxs-lookup"><span data-stu-id="2db64-203">3.9063</span></span> |     - |  <span data-ttu-id="2db64-204">540.09 KB</span><span class="sxs-lookup"><span data-stu-id="2db64-204">540.09 KB</span></span> |
|     <span data-ttu-id="2db64-205">この順位付け</span><span class="sxs-lookup"><span data-stu-id="2db64-205">ProjectOnlyRanking</span></span> |   <span data-ttu-id="2db64-206">910.9 us</span><span class="sxs-lookup"><span data-stu-id="2db64-206">910.9 us</span></span> | <span data-ttu-id="2db64-207">20.91 us</span><span class="sxs-lookup"><span data-stu-id="2db64-207">20.91 us</span></span> | <span data-ttu-id="2db64-208">61.65 us</span><span class="sxs-lookup"><span data-stu-id="2db64-208">61.65 us</span></span> |   <span data-ttu-id="2db64-209">892.9 us</span><span class="sxs-lookup"><span data-stu-id="2db64-209">892.9 us</span></span> |  <span data-ttu-id="2db64-210">1.46</span><span class="sxs-lookup"><span data-stu-id="2db64-210">1.46</span></span> |    <span data-ttu-id="2db64-211">0.14</span><span class="sxs-lookup"><span data-stu-id="2db64-211">0.14</span></span> |  <span data-ttu-id="2db64-212">41.0156</span><span class="sxs-lookup"><span data-stu-id="2db64-212">41.0156</span></span> |  <span data-ttu-id="2db64-213">0.9766</span><span class="sxs-lookup"><span data-stu-id="2db64-213">0.9766</span></span> |     - |  <span data-ttu-id="2db64-214">252.08 KB</span><span class="sxs-lookup"><span data-stu-id="2db64-214">252.08 KB</span></span> |
|    <span data-ttu-id="2db64-215">CalculateInDatabase</span><span class="sxs-lookup"><span data-stu-id="2db64-215">CalculateInDatabase</span></span> |   <span data-ttu-id="2db64-216">627.1 us</span><span class="sxs-lookup"><span data-stu-id="2db64-216">627.1 us</span></span> | <span data-ttu-id="2db64-217">14.58 us</span><span class="sxs-lookup"><span data-stu-id="2db64-217">14.58 us</span></span> | <span data-ttu-id="2db64-218">42.54 us</span><span class="sxs-lookup"><span data-stu-id="2db64-218">42.54 us</span></span> |   <span data-ttu-id="2db64-219">626.4 us</span><span class="sxs-lookup"><span data-stu-id="2db64-219">626.4 us</span></span> |  <span data-ttu-id="2db64-220">1.00</span><span class="sxs-lookup"><span data-stu-id="2db64-220">1.00</span></span> |    <span data-ttu-id="2db64-221">0.00</span><span class="sxs-lookup"><span data-stu-id="2db64-221">0.00</span></span> |   <span data-ttu-id="2db64-222">4.8828</span><span class="sxs-lookup"><span data-stu-id="2db64-222">4.8828</span></span> |       - |     - |   <span data-ttu-id="2db64-223">33.27 KB</span><span class="sxs-lookup"><span data-stu-id="2db64-223">33.27 KB</span></span> |

> [!NOTE]
> <span data-ttu-id="2db64-224">メソッドがメソッド内でコンテキストをインスタンス化および破棄すると、これらの操作はベンチマークに対してカウントされますが、厳密にはクエリプロセスには含まれません。</span><span class="sxs-lookup"><span data-stu-id="2db64-224">As the methods instantiate and dispose the context within the method, these operations are counted for the benchmark, although strictly speaking they are not part of the querying process.</span></span> <span data-ttu-id="2db64-225">これは、2つの代替方法を比較することが目的である場合 (コンテキストのインスタンス化と破棄は同じであるため)、操作全体に対してより包括的な測定を行うことであるかどうかに関係ありません。</span><span class="sxs-lookup"><span data-stu-id="2db64-225">This should not matter if the goal is to compare two alternatives to one another (since the context instantiation and disposal are the same), and gives a more holistic measurement for the entire operation.</span></span>

<span data-ttu-id="2db64-226">BenchmarkDotNet の1つの制限は、指定したメソッドの単純な単一スレッドパフォーマンスを測定するため、同時実行シナリオのベンチマークには適していません。</span><span class="sxs-lookup"><span data-stu-id="2db64-226">One limitation of BenchmarkDotNet is that it measures simple, single-thread performance of the methods you provide, and is therefore not well-suited for benchmarking concurrent scenarios.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="2db64-227">ベンチマークの実行時には、実稼働データと同様のデータをデータベースに保持するようにしてください。そうしないと、ベンチマーク結果が実稼働環境での実際のパフォーマンスを表していない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="2db64-227">Always make sure to have data in your database that is similar to production data when benchmarking, otherwise the benchmark results may not represent actual performance in production.</span></span>
