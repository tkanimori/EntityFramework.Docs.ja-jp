---
title: パフォーマンスのモデリング-EF Core
description: Entity Framework Core を使用する場合の効率的なモデリング
author: roji
ms.date: 12/1/2020
uid: core/performance/modeling-for-performance
ms.openlocfilehash: fc16ec67c3865aa7b7a95519463ca7493a2709b0
ms.sourcegitcommit: 4860d036ea0fb392c28799907bcc924c987d2d7b
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/17/2020
ms.locfileid: "97657728"
---
# <a name="modeling-for-performance"></a>パフォーマンスのモデリング

多くの場合、モデル化の方法により、アプリケーションのパフォーマンスに大きな影響が及ぶ可能性があります。適切に正規化された "正しい" モデルは、通常は出発点として適していますが、実際のアプリケーションでは、実用的な侵害の中には優れたパフォーマンスを実現するために長い時間がかかることがあります。 実稼働環境でアプリケーションを実行した後にモデルを変更するのは非常に困難であるため、初期モデルを作成する場合は、パフォーマンスを考慮する必要があります。

## <a name="denormalization-and-caching"></a>非正規化とキャッシュ

*非正規* 化とは、スキーマに冗長なデータを追加することです。通常は、クエリの実行時に結合を排除するために使用します。 たとえば、ブログや投稿を含むモデルの場合は、各投稿に評価があるので、ブログの平均評価を頻繁に表示することが必要になる場合があります。 これに対する単純なアプローチでは、投稿をブログでグループ化し、クエリの一部として平均を計算します。ただし、この場合、2つのテーブル間にコストのかかる結合が必要です。 非正規化は、すべての投稿の計算された平均をブログの新しい列に追加します。これにより、結合または計算を行わずに、すぐにアクセスできるようになります。

上の図は、記事のブログにキャッシュされている投稿からの集計情報を *キャッシュの形式* として表示できます。キャッシュと同様に、キャッシュされた値はキャッシュに格納されているデータで最新の状態に保つことができます。 多くの場合、キャッシュされたデータは少し遅れます。たとえば、上記の例では、通常、ブログの平均評価が特定の時点で完全に最新ではないことが妥当です。 そのような場合は、これを再計算してから、次のようにします。それ以外の場合は、キャッシュされた値を最新の状態に保つために、より複雑なシステムを設定する必要があります。

ここでは、EF Core での非正規化とキャッシュの手法について詳しく説明し、ドキュメントの関連セクションを参照しています。

### <a name="stored-computed-columns"></a>格納される計算列

キャッシュするデータが同じテーブル内の他の列の製品である場合は、格納されている [計算列](xref:core/modeling/generated-properties#computed-columns) を完全なソリューションにすることができます。 たとえば、には `Customer` `FirstName` 列と列があり `LastName` ますが、顧客の *氏名* を検索する必要がある場合があります。 格納されている計算列は、その行が変更されるたびに再計算されるデータベースによって自動的に管理されます。また、クエリを高速化するためにインデックスを定義することもできます。

### <a name="update-cache-columns-when-inputs-change"></a>入力の変更時にキャッシュ列を更新する

キャッシュされた列がテーブルの行の外部からの入力を参照する必要がある場合、計算列は使用できません。 ただし、入力が変わるたびに列を再計算することはできます。たとえば、投稿が変更、追加、または削除されるたびに、ブログの平均評価を再計算することができます。 再計算が必要な場合は、正確な条件を確認してください。そうでない場合、キャッシュされた値は同期しません。

これを行う1つの方法は、通常の EF Core API を使用して自分で更新プログラムを実行することです。 `SaveChanges`[イベント](xref:core/logging-events-diagnostics/events)または[インターセプター](xref:core/logging-events-diagnostics/interceptors#savechanges-interception)を使用すると、投稿が更新されているかどうかを自動的に確認し、その方法で再計算を実行できます。 これには、追加のコマンドを送信する必要があるため、通常は追加のデータベースのラウンドトリップが必要です。

パフォーマンスを重視するアプリケーションでは、データベースの再計算を自動的に実行するようにデータベーストリガーを定義できます。 これにより、余分なデータベースのラウンドトリップが保存され、メインの更新と同じトランザクション内で自動的に発生します。セットアップが簡単になります。 EF には、トリガーを作成または管理するための特定の API は用意されていませんが、 [空の移行を作成し、生の SQL を使用](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql)してトリガーの定義を追加することは、まったく問題ありません。

### <a name="materialized-views"></a>具体化されたビュー

具体化されたビューは通常のビューに似ていますが、ビューにクエリを実行するたびに計算されるのではなく、データがディスク ("具体化された") に格納される点が異なります。 このツールは、単純に1つのキャッシュ列を既存のデータベースに追加するのではなく、複雑でコストのかかるクエリの結果を、通常のテーブルの場合と同じようにキャッシュする必要がある場合に便利です。これらの結果は、計算や結合が行われなくても、非常に安価にクエリを実行できます。 計算列とは異なり、具体化されたビューは、基になるテーブルが変更されても自動的に更新されません。手動で更新する必要があります。 キャッシュされたデータの遅延が生じる可能性がある場合は、タイマーを使用してビューを更新できます。別の方法として、特定のデータベースイベントが発生した後に、具体化されたビューを確認するようにデータベーストリガーを設定することもできます。

EF は、現在、ビューを作成または管理するための特定の API を提供していません。しかし、空の移行を [作成し、未加工の SQL を使用してビュー定義を追加](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql)することは、まったく問題ありません。

## <a name="inheritance-mapping"></a>継承のマッピング

このセクションを続行する前に [、継承に関する専用ページ](xref:core/modeling/inheritance) を読むことをお勧めします。

EF Core は、現在、継承モデルをリレーショナルデータベースにマップする2つの手法をサポートしています。

* **階層ごとのテーブル** (TPH)。クラスの .net 階層全体が1つのデータベーステーブルにマップされます。
* **型ごとのテーブル** (TPT)。 .net 階層の各型は、データベース内の別のテーブルにマップされます。

継承マッピング手法を選択すると、アプリケーションのパフォーマンスに大きな影響を与える可能性があります。選択肢にコミットする前に、慎重に測定することをお勧めします。

"クリーナー" の手法であるように見えることがあるため、TPT を選択することがあります。.NET 型ごとに個別のテーブルを作成すると、データベーススキーマは .NET 型階層に似たものになります。 さらに、TPH は1つのテーブル内の階層全体を表す必要があるため、行には実際に保持されている型に関係なく *すべて* の列があり、関連のない列は常に空で、使用されません。 見えるから "unclean" へのマッピング手法を除けば、これらの空の列がデータベース内の領域を大量に消費し、パフォーマンスが低下する可能性があります。

しかし、測定では、ほとんどの場合、TPT がパフォーマンスの観点からの下位のマッピング手法であることが示されています。TPH のすべてのデータが1つのテーブルから取得される場合、TPT クエリは複数のテーブルに結合する必要があり、結合はリレーショナルデータベースでのパフォーマンスの問題の主な原因の1つです。 また、データベースは一般に、空の列に対応する傾向があり、 [SQL Server スパース列](/sql/relational-databases/tables/use-sparse-columns) などの機能により、このオーバーヘッドをさらに削減できます。

具体的な例については、7型の階層を持つ単純なモデルを設定する [このベンチマークをご覧ください](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/Inheritance.cs) 。5000行は合計35000行ごとにシード処理されます。ベンチマークでは、データベースからすべての行が読み込まれます。

| Method |     平均 |   エラー |  StdDev |     Gen 0 |     Gen 1 |     Gen 2 | Allocated |
|------- |---------:|--------:|--------:|----------:|----------:|----------:|----------:|
|    TPH | 132.3 ミリ秒 | 2.29 ミリ秒 | 2.03 ミリ秒 | 8000.0000 | 3000.0000 | 1250.0000 |  44.49 MB |
|    TPT | 201.3 ミリ秒 | 3.32 ミリ秒 | 3.10 ミリ秒 | 9000.0000 | 4000.0000 |         - |  61.84 MB |

ご覧のように、TPH はこのシナリオの TPT よりもはるかに効率的です。 実際の結果は、実行されている特定のクエリと階層内のテーブルの数に常に依存しているため、他のクエリではパフォーマンスの差が異なる場合があります。他のクエリをテストするためのテンプレートとして、このベンチマークコードを使用することをお勧めします。
