---
title: パフォーマンスのモデリング-EF Core
description: Entity Framework Core を使用する場合の効率的なモデリング
author: roji
ms.date: 12/1/2020
uid: core/performance/modeling-for-performance
ms.openlocfilehash: fc16ec67c3865aa7b7a95519463ca7493a2709b0
ms.sourcegitcommit: 4860d036ea0fb392c28799907bcc924c987d2d7b
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/17/2020
ms.locfileid: "97657728"
---
# <a name="modeling-for-performance"></a><span data-ttu-id="d2e22-103">パフォーマンスのモデリング</span><span class="sxs-lookup"><span data-stu-id="d2e22-103">Modeling for Performance</span></span>

<span data-ttu-id="d2e22-104">多くの場合、モデル化の方法により、アプリケーションのパフォーマンスに大きな影響が及ぶ可能性があります。適切に正規化された "正しい" モデルは、通常は出発点として適していますが、実際のアプリケーションでは、実用的な侵害の中には優れたパフォーマンスを実現するために長い時間がかかることがあります。</span><span class="sxs-lookup"><span data-stu-id="d2e22-104">In many cases, the way you model can have a profound impact on the performance of your application; while a properly normalized and "correct" model is usually a good starting point, in real-world applications some pragmatic compromises can go a long way for achieving good performance.</span></span> <span data-ttu-id="d2e22-105">実稼働環境でアプリケーションを実行した後にモデルを変更するのは非常に困難であるため、初期モデルを作成する場合は、パフォーマンスを考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d2e22-105">Since it's quite difficult to change your model once an application is running in production, it's worth keeping performance in mind when creating the initial model.</span></span>

## <a name="denormalization-and-caching"></a><span data-ttu-id="d2e22-106">非正規化とキャッシュ</span><span class="sxs-lookup"><span data-stu-id="d2e22-106">Denormalization and caching</span></span>

<span data-ttu-id="d2e22-107">*非正規* 化とは、スキーマに冗長なデータを追加することです。通常は、クエリの実行時に結合を排除するために使用します。</span><span class="sxs-lookup"><span data-stu-id="d2e22-107">*Denormalization* is the practice of adding redundant data to your schema, usually in order to eliminate joins when querying.</span></span> <span data-ttu-id="d2e22-108">たとえば、ブログや投稿を含むモデルの場合は、各投稿に評価があるので、ブログの平均評価を頻繁に表示することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="d2e22-108">For example, for a model with Blogs and Posts, where each Post has a Rating, you may be required to frequently show the average rating of the Blog.</span></span> <span data-ttu-id="d2e22-109">これに対する単純なアプローチでは、投稿をブログでグループ化し、クエリの一部として平均を計算します。ただし、この場合、2つのテーブル間にコストのかかる結合が必要です。</span><span class="sxs-lookup"><span data-stu-id="d2e22-109">The simple approach to this would group the Posts by their Blog, and calculate the average as part of the query; but this requires a costly join between the two tables.</span></span> <span data-ttu-id="d2e22-110">非正規化は、すべての投稿の計算された平均をブログの新しい列に追加します。これにより、結合または計算を行わずに、すぐにアクセスできるようになります。</span><span class="sxs-lookup"><span data-stu-id="d2e22-110">Denormalization would add the calculated average of all posts to a new column on Blog, so that it is immediately accessible, without joining or calculating.</span></span>

<span data-ttu-id="d2e22-111">上の図は、記事のブログにキャッシュされている投稿からの集計情報を *キャッシュの形式* として表示できます。キャッシュと同様に、キャッシュされた値はキャッシュに格納されているデータで最新の状態に保つことができます。</span><span class="sxs-lookup"><span data-stu-id="d2e22-111">The above can be viewed as a form of *caching* - aggregate information from the Posts is cached on their Blog; and like with any caching, the problem is how to keep the cached value up to date with the data it's caching.</span></span> <span data-ttu-id="d2e22-112">多くの場合、キャッシュされたデータは少し遅れます。たとえば、上記の例では、通常、ブログの平均評価が特定の時点で完全に最新ではないことが妥当です。</span><span class="sxs-lookup"><span data-stu-id="d2e22-112">In many cases, it's OK for the cached data to lag for a bit; for example, in the example above, it's usually reasonable for the blog's average rating to not be completely up to date at any given point.</span></span> <span data-ttu-id="d2e22-113">そのような場合は、これを再計算してから、次のようにします。それ以外の場合は、キャッシュされた値を最新の状態に保つために、より複雑なシステムを設定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d2e22-113">If that's the case, you can have it recalculated every now and then; otherwise, a more elaborate system must be set up to keep the cached values up to date.</span></span>

<span data-ttu-id="d2e22-114">ここでは、EF Core での非正規化とキャッシュの手法について詳しく説明し、ドキュメントの関連セクションを参照しています。</span><span class="sxs-lookup"><span data-stu-id="d2e22-114">The following details some techniques for denormalization and caching in EF Core, and points to the relevant sections in the documentation.</span></span>

### <a name="stored-computed-columns"></a><span data-ttu-id="d2e22-115">格納される計算列</span><span class="sxs-lookup"><span data-stu-id="d2e22-115">Stored computed columns</span></span>

<span data-ttu-id="d2e22-116">キャッシュするデータが同じテーブル内の他の列の製品である場合は、格納されている [計算列](xref:core/modeling/generated-properties#computed-columns) を完全なソリューションにすることができます。</span><span class="sxs-lookup"><span data-stu-id="d2e22-116">If the data to be cached is a product of other columns in the same table, then a [stored computed column](xref:core/modeling/generated-properties#computed-columns) can be a perfect solution.</span></span> <span data-ttu-id="d2e22-117">たとえば、には `Customer` `FirstName` 列と列があり `LastName` ますが、顧客の *氏名* を検索する必要がある場合があります。</span><span class="sxs-lookup"><span data-stu-id="d2e22-117">For example, a `Customer` may have `FirstName` and `LastName` columns, but we may need to search by the customer's *full name*.</span></span> <span data-ttu-id="d2e22-118">格納されている計算列は、その行が変更されるたびに再計算されるデータベースによって自動的に管理されます。また、クエリを高速化するためにインデックスを定義することもできます。</span><span class="sxs-lookup"><span data-stu-id="d2e22-118">A stored computed column is automatically maintained by the database - which recalculates it whenever the row is changed - and you can even define an index over it to speed up queries.</span></span>

### <a name="update-cache-columns-when-inputs-change"></a><span data-ttu-id="d2e22-119">入力の変更時にキャッシュ列を更新する</span><span class="sxs-lookup"><span data-stu-id="d2e22-119">Update cache columns when inputs change</span></span>

<span data-ttu-id="d2e22-120">キャッシュされた列がテーブルの行の外部からの入力を参照する必要がある場合、計算列は使用できません。</span><span class="sxs-lookup"><span data-stu-id="d2e22-120">If your cached column needs to reference inputs from outside the table's row, you cannot use computed columns.</span></span> <span data-ttu-id="d2e22-121">ただし、入力が変わるたびに列を再計算することはできます。たとえば、投稿が変更、追加、または削除されるたびに、ブログの平均評価を再計算することができます。</span><span class="sxs-lookup"><span data-stu-id="d2e22-121">However, it is still possible to recalculate the column whenever its input changes; for example, you could recalculate the average Blog's rating every time a Post is changed, added or removed.</span></span> <span data-ttu-id="d2e22-122">再計算が必要な場合は、正確な条件を確認してください。そうでない場合、キャッシュされた値は同期しません。</span><span class="sxs-lookup"><span data-stu-id="d2e22-122">Be sure to identify the exact conditions when recalculation is needed, otherwise your cached value will go out of sync.</span></span>

<span data-ttu-id="d2e22-123">これを行う1つの方法は、通常の EF Core API を使用して自分で更新プログラムを実行することです。</span><span class="sxs-lookup"><span data-stu-id="d2e22-123">One way to do this, is to perform the update yourself, via the regular EF Core API.</span></span> <span data-ttu-id="d2e22-124">`SaveChanges`[イベント](xref:core/logging-events-diagnostics/events)または[インターセプター](xref:core/logging-events-diagnostics/interceptors#savechanges-interception)を使用すると、投稿が更新されているかどうかを自動的に確認し、その方法で再計算を実行できます。</span><span class="sxs-lookup"><span data-stu-id="d2e22-124">`SaveChanges` [Events](xref:core/logging-events-diagnostics/events) or [interceptors](xref:core/logging-events-diagnostics/interceptors#savechanges-interception) can be used to automatically check if any Posts are being updated, and to perform the recalculation that way.</span></span> <span data-ttu-id="d2e22-125">これには、追加のコマンドを送信する必要があるため、通常は追加のデータベースのラウンドトリップが必要です。</span><span class="sxs-lookup"><span data-stu-id="d2e22-125">Note that this typically entails additional database roundtrips, as additional commands must be sent.</span></span>

<span data-ttu-id="d2e22-126">パフォーマンスを重視するアプリケーションでは、データベースの再計算を自動的に実行するようにデータベーストリガーを定義できます。</span><span class="sxs-lookup"><span data-stu-id="d2e22-126">For more perf-sensitive applications, database triggers can be defined to automatically perform the recalculation in the database.</span></span> <span data-ttu-id="d2e22-127">これにより、余分なデータベースのラウンドトリップが保存され、メインの更新と同じトランザクション内で自動的に発生します。セットアップが簡単になります。</span><span class="sxs-lookup"><span data-stu-id="d2e22-127">This saves the extra database roundtrips, automatically occurs within the same transaction as the main update, and can be simpler to set up.</span></span> <span data-ttu-id="d2e22-128">EF には、トリガーを作成または管理するための特定の API は用意されていませんが、 [空の移行を作成し、生の SQL を使用](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql)してトリガーの定義を追加することは、まったく問題ありません。</span><span class="sxs-lookup"><span data-stu-id="d2e22-128">EF doesn't provide any specific API for creating or maintaining triggers, but it's perfectly fine to [create an empty migration and add the trigger definition via raw SQL](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql).</span></span>

### <a name="materialized-views"></a><span data-ttu-id="d2e22-129">具体化されたビュー</span><span class="sxs-lookup"><span data-stu-id="d2e22-129">Materialized views</span></span>

<span data-ttu-id="d2e22-130">具体化されたビューは通常のビューに似ていますが、ビューにクエリを実行するたびに計算されるのではなく、データがディスク ("具体化された") に格納される点が異なります。</span><span class="sxs-lookup"><span data-stu-id="d2e22-130">Materialized views are similar to regular views, except that their data is stored on disk ("materialized"), rather than calculated every time when the view is queried.</span></span> <span data-ttu-id="d2e22-131">このツールは、単純に1つのキャッシュ列を既存のデータベースに追加するのではなく、複雑でコストのかかるクエリの結果を、通常のテーブルの場合と同じようにキャッシュする必要がある場合に便利です。これらの結果は、計算や結合が行われなくても、非常に安価にクエリを実行できます。</span><span class="sxs-lookup"><span data-stu-id="d2e22-131">This tool is useful when you don't want to simply add a single cache column to an existing database, but rather want to cache the entire resultset of a complicated and expensive query's results, just as if it were a regular table; these results can then be queried very cheaply without any computation or joins happening.</span></span> <span data-ttu-id="d2e22-132">計算列とは異なり、具体化されたビューは、基になるテーブルが変更されても自動的に更新されません。手動で更新する必要があります。</span><span class="sxs-lookup"><span data-stu-id="d2e22-132">Unlike computed columns, materialized views aren't automatically updated when their underlying tables change - they must be manually refreshed.</span></span> <span data-ttu-id="d2e22-133">キャッシュされたデータの遅延が生じる可能性がある場合は、タイマーを使用してビューを更新できます。別の方法として、特定のデータベースイベントが発生した後に、具体化されたビューを確認するようにデータベーストリガーを設定することもできます。</span><span class="sxs-lookup"><span data-stu-id="d2e22-133">If the cached data can lag, refreshing the view can be done via a timer; another option is to set up database triggers to review a materialized view once certain database events occur.</span></span>

<span data-ttu-id="d2e22-134">EF は、現在、ビューを作成または管理するための特定の API を提供していません。しかし、空の移行を [作成し、未加工の SQL を使用してビュー定義を追加](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql)することは、まったく問題ありません。</span><span class="sxs-lookup"><span data-stu-id="d2e22-134">EF doesn't currently provide any specific API for creating or maintaining views, materialized or otherwise; but it's perfectly fine to [create an empty migration and add the view definition via raw SQL](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql).</span></span>

## <a name="inheritance-mapping"></a><span data-ttu-id="d2e22-135">継承のマッピング</span><span class="sxs-lookup"><span data-stu-id="d2e22-135">Inheritance mapping</span></span>

<span data-ttu-id="d2e22-136">このセクションを続行する前に [、継承に関する専用ページ](xref:core/modeling/inheritance) を読むことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="d2e22-136">It's recommended to read [the dedicated page on inheritance](xref:core/modeling/inheritance) before continuing with this section.</span></span>

<span data-ttu-id="d2e22-137">EF Core は、現在、継承モデルをリレーショナルデータベースにマップする2つの手法をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="d2e22-137">EF Core currently supports two techniques for mapping an inheritance model to a relational database:</span></span>

* <span data-ttu-id="d2e22-138">**階層ごとのテーブル** (TPH)。クラスの .net 階層全体が1つのデータベーステーブルにマップされます。</span><span class="sxs-lookup"><span data-stu-id="d2e22-138">**Table-per-hierarchy** (TPH), in which an entire .NET hierarchy of classes is mapped to a single database table</span></span>
* <span data-ttu-id="d2e22-139">**型ごとのテーブル** (TPT)。 .net 階層の各型は、データベース内の別のテーブルにマップされます。</span><span class="sxs-lookup"><span data-stu-id="d2e22-139">**Table-per-type** (TPT), in which each type in the .NET hierarchy is mapped to a different table in the database.</span></span>

<span data-ttu-id="d2e22-140">継承マッピング手法を選択すると、アプリケーションのパフォーマンスに大きな影響を与える可能性があります。選択肢にコミットする前に、慎重に測定することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="d2e22-140">The choice of inheritance mapping technique can have a considerable impact on application performance - it's recommended to carefully measure before committing to a choice.</span></span>

<span data-ttu-id="d2e22-141">"クリーナー" の手法であるように見えることがあるため、TPT を選択することがあります。.NET 型ごとに個別のテーブルを作成すると、データベーススキーマは .NET 型階層に似たものになります。</span><span class="sxs-lookup"><span data-stu-id="d2e22-141">People sometimes choose TPT because it appears to be the "cleaner" technique; a separate table for each .NET type makes the database schema look similar to the .NET type hierarchy.</span></span> <span data-ttu-id="d2e22-142">さらに、TPH は1つのテーブル内の階層全体を表す必要があるため、行には実際に保持されている型に関係なく *すべて* の列があり、関連のない列は常に空で、使用されません。</span><span class="sxs-lookup"><span data-stu-id="d2e22-142">In addition, since TPH must represent the entire hierarchy in a single table, rows have *all* columns regardless of the type actually being held in the row, and unrelated columns are always empty and unused.</span></span> <span data-ttu-id="d2e22-143">見えるから "unclean" へのマッピング手法を除けば、これらの空の列がデータベース内の領域を大量に消費し、パフォーマンスが低下する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="d2e22-143">Aside from seeming to be an "unclean" mapping technique, many believe that these empty columns take up considerable space in the database and may hurt performance as well.</span></span>

<span data-ttu-id="d2e22-144">しかし、測定では、ほとんどの場合、TPT がパフォーマンスの観点からの下位のマッピング手法であることが示されています。TPH のすべてのデータが1つのテーブルから取得される場合、TPT クエリは複数のテーブルに結合する必要があり、結合はリレーショナルデータベースでのパフォーマンスの問題の主な原因の1つです。</span><span class="sxs-lookup"><span data-stu-id="d2e22-144">However, measuring shows that TPT is in most cases the inferior mapping technique from a performance standpoint; where all data in TPH comes from a single table, TPT queries must join together multiple tables, and joins are one of the primary sources of performance issues in relational databases.</span></span> <span data-ttu-id="d2e22-145">また、データベースは一般に、空の列に対応する傾向があり、 [SQL Server スパース列](/sql/relational-databases/tables/use-sparse-columns) などの機能により、このオーバーヘッドをさらに削減できます。</span><span class="sxs-lookup"><span data-stu-id="d2e22-145">Databases also generally tend to deal well with empty columns, and features such as [SQL Server sparse columns](/sql/relational-databases/tables/use-sparse-columns) can reduce this overhead even further.</span></span>

<span data-ttu-id="d2e22-146">具体的な例については、7型の階層を持つ単純なモデルを設定する [このベンチマークをご覧ください](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/Inheritance.cs) 。5000行は合計35000行ごとにシード処理されます。ベンチマークでは、データベースからすべての行が読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="d2e22-146">For a concrete example, [see this benchmark](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/Inheritance.cs) which sets up a simple model with a 7-type hierarchy; 5000 rows are seeded for each type - totalling 35000 rows - and the benchmark simply loads all rows from the database:</span></span>

| <span data-ttu-id="d2e22-147">Method</span><span class="sxs-lookup"><span data-stu-id="d2e22-147">Method</span></span> |     <span data-ttu-id="d2e22-148">平均</span><span class="sxs-lookup"><span data-stu-id="d2e22-148">Mean</span></span> |   <span data-ttu-id="d2e22-149">エラー</span><span class="sxs-lookup"><span data-stu-id="d2e22-149">Error</span></span> |  <span data-ttu-id="d2e22-150">StdDev</span><span class="sxs-lookup"><span data-stu-id="d2e22-150">StdDev</span></span> |     <span data-ttu-id="d2e22-151">Gen 0</span><span class="sxs-lookup"><span data-stu-id="d2e22-151">Gen 0</span></span> |     <span data-ttu-id="d2e22-152">Gen 1</span><span class="sxs-lookup"><span data-stu-id="d2e22-152">Gen 1</span></span> |     <span data-ttu-id="d2e22-153">Gen 2</span><span class="sxs-lookup"><span data-stu-id="d2e22-153">Gen 2</span></span> | <span data-ttu-id="d2e22-154">Allocated</span><span class="sxs-lookup"><span data-stu-id="d2e22-154">Allocated</span></span> |
|------- |---------:|--------:|--------:|----------:|----------:|----------:|----------:|
|    <span data-ttu-id="d2e22-155">TPH</span><span class="sxs-lookup"><span data-stu-id="d2e22-155">TPH</span></span> | <span data-ttu-id="d2e22-156">132.3 ミリ秒</span><span class="sxs-lookup"><span data-stu-id="d2e22-156">132.3 ms</span></span> | <span data-ttu-id="d2e22-157">2.29 ミリ秒</span><span class="sxs-lookup"><span data-stu-id="d2e22-157">2.29 ms</span></span> | <span data-ttu-id="d2e22-158">2.03 ミリ秒</span><span class="sxs-lookup"><span data-stu-id="d2e22-158">2.03 ms</span></span> | <span data-ttu-id="d2e22-159">8000.0000</span><span class="sxs-lookup"><span data-stu-id="d2e22-159">8000.0000</span></span> | <span data-ttu-id="d2e22-160">3000.0000</span><span class="sxs-lookup"><span data-stu-id="d2e22-160">3000.0000</span></span> | <span data-ttu-id="d2e22-161">1250.0000</span><span class="sxs-lookup"><span data-stu-id="d2e22-161">1250.0000</span></span> |  <span data-ttu-id="d2e22-162">44.49 MB</span><span class="sxs-lookup"><span data-stu-id="d2e22-162">44.49 MB</span></span> |
|    <span data-ttu-id="d2e22-163">TPT</span><span class="sxs-lookup"><span data-stu-id="d2e22-163">TPT</span></span> | <span data-ttu-id="d2e22-164">201.3 ミリ秒</span><span class="sxs-lookup"><span data-stu-id="d2e22-164">201.3 ms</span></span> | <span data-ttu-id="d2e22-165">3.32 ミリ秒</span><span class="sxs-lookup"><span data-stu-id="d2e22-165">3.32 ms</span></span> | <span data-ttu-id="d2e22-166">3.10 ミリ秒</span><span class="sxs-lookup"><span data-stu-id="d2e22-166">3.10 ms</span></span> | <span data-ttu-id="d2e22-167">9000.0000</span><span class="sxs-lookup"><span data-stu-id="d2e22-167">9000.0000</span></span> | <span data-ttu-id="d2e22-168">4000.0000</span><span class="sxs-lookup"><span data-stu-id="d2e22-168">4000.0000</span></span> |         - |  <span data-ttu-id="d2e22-169">61.84 MB</span><span class="sxs-lookup"><span data-stu-id="d2e22-169">61.84 MB</span></span> |

<span data-ttu-id="d2e22-170">ご覧のように、TPH はこのシナリオの TPT よりもはるかに効率的です。</span><span class="sxs-lookup"><span data-stu-id="d2e22-170">As can be seen, TPH is considerably more efficient than TPT for this scenario.</span></span> <span data-ttu-id="d2e22-171">実際の結果は、実行されている特定のクエリと階層内のテーブルの数に常に依存しているため、他のクエリではパフォーマンスの差が異なる場合があります。他のクエリをテストするためのテンプレートとして、このベンチマークコードを使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="d2e22-171">Note that actual results always depend on the specific query being executed and the number of tables in the hierarchy, so other queries may show a different performance gap; you're encouraged to use this benchmark code as a template for testing other queries.</span></span>
