---
title: 効率的なクエリ-EF Core
description: Entity Framework Core を使用した効率的なクエリのパフォーマンスガイド
author: roji
ms.date: 12/1/2020
uid: core/performance/efficient-querying
ms.openlocfilehash: acd5388745e74a42925c8500ce610aef83e75384
ms.sourcegitcommit: 4860d036ea0fb392c28799907bcc924c987d2d7b
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/17/2020
ms.locfileid: "97657722"
---
# <a name="efficient-querying"></a><span data-ttu-id="9808f-103">効率的なクエリ</span><span class="sxs-lookup"><span data-stu-id="9808f-103">Efficient Querying</span></span>

<span data-ttu-id="9808f-104">効率的にクエリを実行することは、インデックス、関連するエンティティの読み込み方法、その他多くの要素として、さまざまな主題を対象としています。</span><span class="sxs-lookup"><span data-stu-id="9808f-104">Querying efficiently is a vast subject, that covers subjects as wide-ranging as indexes, related entity loading strategies, and many others.</span></span> <span data-ttu-id="9808f-105">このセクションでは、クエリの実行速度を向上させる一般的なテーマと、ユーザーが通常遭遇する落とし穴について詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="9808f-105">This section details some common themes for making your queries faster, and pitfalls users typically encounter.</span></span>

## <a name="use-indexes-properly"></a><span data-ttu-id="9808f-106">インデックスを適切に使用する</span><span class="sxs-lookup"><span data-stu-id="9808f-106">Use indexes properly</span></span>

<span data-ttu-id="9808f-107">クエリが高速に実行されるかどうかを判断する主な要因は、適切なインデックスを使用するかどうかを決定することです。データベースは通常、大量のデータを保持するために使用され、テーブル全体をスキャンするクエリは、重大なパフォーマンスの問題の原因になります。</span><span class="sxs-lookup"><span data-stu-id="9808f-107">The main deciding factor in whether a query runs fast or not is whether it will properly utilize indexes where appropriate: databases are typically used to hold large amounts of data, and queries which traverse entire tables are typically sources of serious performance issues.</span></span> <span data-ttu-id="9808f-108">インデックス作成の問題は、特定のクエリでインデックスを使用するかどうかがすぐに明らかにならないため、簡単に見つけることができません。</span><span class="sxs-lookup"><span data-stu-id="9808f-108">Indexing issues aren't easy to spot, because it isn't immediately obvious whether a given query will use an index or not.</span></span> <span data-ttu-id="9808f-109">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="9808f-109">For example:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#Indexes)]

<span data-ttu-id="9808f-110">インデックス作成の問題を見つけるには、まず、低速クエリを特定し、データベースのお気に入りのツールを使用してクエリプランを調べることをお勧めします。その方法の詳細については、「 [パフォーマンス診断](xref:core/performance/performance-diagnosis) 」ページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="9808f-110">A good way to spot indexing issues is to first pinpoint a slow query, and then examine its query plan via your database's favorite tool; see the [performance diagnosis](xref:core/performance/performance-diagnosis) page for more information on how to do that.</span></span> <span data-ttu-id="9808f-111">クエリプランでは、クエリがテーブル全体を通過するか、インデックスを使用するかが表示されます。</span><span class="sxs-lookup"><span data-stu-id="9808f-111">The query plan displays whether the query traverses the entire table, or uses an index.</span></span>

<span data-ttu-id="9808f-112">一般的な規則として、インデックスを使用したり、関連するパフォーマンスの問題を診断したりするための特別な EF の知識はありません。インデックスに関連する一般的なデータベースナレッジは、ef を使用しないアプリケーションの場合と同様に、EF アプリケーションに関連しています。</span><span class="sxs-lookup"><span data-stu-id="9808f-112">As a general rule, there isn't any special EF knowledge to using indexes or diagnosing performance issues related to them; general database knowledge related to indexes is just as relevant to EF applications as to applications not using EF.</span></span> <span data-ttu-id="9808f-113">次に、インデックスを使用する場合に留意すべき一般的なガイドラインをいくつか示します。</span><span class="sxs-lookup"><span data-stu-id="9808f-113">The following lists some general guidelines to keep in mind when using indexes:</span></span>

* <span data-ttu-id="9808f-114">インデックスはクエリを高速化しますが、最新の状態に保つ必要があるため、更新の速度も低下します。</span><span class="sxs-lookup"><span data-stu-id="9808f-114">While indexes speed up queries, they also slow down updates since they need to be kept up-to-date.</span></span> <span data-ttu-id="9808f-115">不要なインデックスを定義しないでください。インデックス [フィルター](xref:core/modeling/indexes#index-filter) を使用してインデックスを行のサブセットに制限することを検討してください。これにより、このオーバーヘッドが減少します。</span><span class="sxs-lookup"><span data-stu-id="9808f-115">Avoid defining indexes which aren't needed, and consider using [index filters](xref:core/modeling/indexes#index-filter) to limit the index to a subset of the rows, thereby reducing this overhead.</span></span>
* <span data-ttu-id="9808f-116">複合インデックスを使用すると、複数の列をフィルター処理するクエリを高速化できますが、順序によっては、インデックスのすべての列に対してフィルター処理を行わないクエリを高速化することもできます。</span><span class="sxs-lookup"><span data-stu-id="9808f-116">Composite indexes can speed up queries which filter on multiple columns, but they can also speed up queries which don't filter on all the index's columns - depending on ordering.</span></span> <span data-ttu-id="9808f-117">たとえば、a 列と b 列のインデックスを使用すると、a と B によってフィルター処理されるクエリだけでなく、によってのみフィルター処理が行われますが、クエリのフィルター処理は B だけで済みます。</span><span class="sxs-lookup"><span data-stu-id="9808f-117">For example, an index on columns A and B speed up queries filtering by A and B, as well as queries filtering only by A, but it does not speed up queries filtering over only by B.</span></span>
* <span data-ttu-id="9808f-118">クエリが列に対する式によってフィルター処理される場合 (例: `price / 2` )、単純なインデックスは使用できません。</span><span class="sxs-lookup"><span data-stu-id="9808f-118">If a query filters by an expression over a column (e.g. `price / 2`), a simple index cannot be used.</span></span> <span data-ttu-id="9808f-119">ただし、 [格納されている保存済みの永続化列](xref:core/modeling/generated-properties#computed-columns) を式に対して定義し、それに対してインデックスを作成することができます。</span><span class="sxs-lookup"><span data-stu-id="9808f-119">However, you can define a [stored persisted column](xref:core/modeling/generated-properties#computed-columns) for your expression, and create an index over that.</span></span> <span data-ttu-id="9808f-120">一部のデータベースでは、式のインデックスもサポートされており、式によってフィルター処理を高速化するために直接使用できます。</span><span class="sxs-lookup"><span data-stu-id="9808f-120">Some databases also support expression indexes, which can be directly used to speed up queries filtering by any expression.</span></span>
* <span data-ttu-id="9808f-121">異なるデータベースを使用すると、さまざまな方法でインデックスを構成できます。多くの場合、EF Core プロバイダーは Fluent API を使用してこれらを公開します。</span><span class="sxs-lookup"><span data-stu-id="9808f-121">Different databases allow indexes to be configured in various ways, and in many cases EF Core providers expose these via the Fluent API.</span></span> <span data-ttu-id="9808f-122">たとえば、SQL Server プロバイダーでは、インデックスが [クラスター化](xref:core/providers/sql-server/indexes#clustering)されているかどうかを構成したり、 [FILL FACTOR](xref:core/providers/sql-server/indexes#fill-factor)を設定したりできます。</span><span class="sxs-lookup"><span data-stu-id="9808f-122">For example, the SQL Server provider allows you to configure whether an index is [clustered](xref:core/providers/sql-server/indexes#clustering), or set its [fill factor](xref:core/providers/sql-server/indexes#fill-factor).</span></span> <span data-ttu-id="9808f-123">詳細については、プロバイダーのドキュメントを参照してください。</span><span class="sxs-lookup"><span data-stu-id="9808f-123">Consult your provider's documentation for more information.</span></span>

## <a name="project-only-properties-you-need"></a><span data-ttu-id="9808f-124">必要なプロパティのみプロジェクト</span><span class="sxs-lookup"><span data-stu-id="9808f-124">Project only properties you need</span></span>

<span data-ttu-id="9808f-125">EF Core を使用すると、エンティティインスタンスのクエリを非常に簡単に実行できるようになり、そのインスタンスをコードで使用できます。</span><span class="sxs-lookup"><span data-stu-id="9808f-125">EF Core makes it very easy to query out entity instances, and then use those instances in code.</span></span> <span data-ttu-id="9808f-126">ただし、エンティティインスタンスに対してクエリを実行すると、データベースから必要以上に多くのデータが返されることがよくあります。</span><span class="sxs-lookup"><span data-stu-id="9808f-126">However, querying entity instances can frequently pull back more data than necessary from your database.</span></span> <span data-ttu-id="9808f-127">以下、具体例に沿って説明します。</span><span class="sxs-lookup"><span data-stu-id="9808f-127">Consider the following:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#ProjectEntities)]

<span data-ttu-id="9808f-128">このコードでは、実際には各ブログのプロパティが必要です `Url` が、ブログエンティティ全体がフェッチされ、不要な列がデータベースから転送されます。</span><span class="sxs-lookup"><span data-stu-id="9808f-128">Although this code only actually needs each Blog's `Url` property, the entire Blog entity is fetched, and unneeded columns are transferred from the database:</span></span>

```sql
SELECT [b].[BlogId], [b].[CreationDate], [b].[Name], [b].[Rating], [b].[Url]
FROM [Blogs] AS [b]
```

<span data-ttu-id="9808f-129">これを最適化するには、を使用して、 `Select` プロジェクトを除外する列を EF に指示します。</span><span class="sxs-lookup"><span data-stu-id="9808f-129">This can be optimized by using `Select` to tell EF which columns to project out:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#ProjectSingleProperty)]

<span data-ttu-id="9808f-130">結果の SQL では、必要な列だけが返されます。</span><span class="sxs-lookup"><span data-stu-id="9808f-130">The resulting SQL pulls back only the needed columns:</span></span>

```csharp
SELECT [b].[Url]
FROM [Blogs] AS [b]
```

<span data-ttu-id="9808f-131">複数の列を射影する必要がある場合は、必要なプロパティを持つ C# 匿名型に射影します。</span><span class="sxs-lookup"><span data-stu-id="9808f-131">If you need to project out more than one column, project out to a C# anonymous type with the properties you want.</span></span>

<span data-ttu-id="9808f-132">この手法は読み取り専用クエリには非常に便利ですが、EF の変更の追跡はエンティティインスタンスでのみ機能するため、フェッチされたブログを *更新* する必要がある場合は、さらに複雑になります。</span><span class="sxs-lookup"><span data-stu-id="9808f-132">Note that this technique is very useful for read-only queries, but things get more complicated if you need to *update* the fetched blogs, since EF's change tracking only works with entity instances.</span></span> <span data-ttu-id="9808f-133">変更したブログインスタンスをアタッチし、変更されたプロパティを EF に指示することにより、エンティティ全体を読み込まずに更新を実行することができますが、これはより高度な手法であり、価値がない場合があります。</span><span class="sxs-lookup"><span data-stu-id="9808f-133">It's possible to perform updates without loading entire entities by attaching a modified Blog instance and telling EF which properties have changed, but that is a more advanced technique that may not be worth it.</span></span>

## <a name="limit-the-resultset-size"></a><span data-ttu-id="9808f-134">Resultset のサイズを制限する</span><span class="sxs-lookup"><span data-stu-id="9808f-134">Limit the resultset size</span></span>

<span data-ttu-id="9808f-135">既定では、クエリはフィルターに一致するすべての行を返します。</span><span class="sxs-lookup"><span data-stu-id="9808f-135">By default, a query returns all rows that matches its filters:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#NoLimit)]

<span data-ttu-id="9808f-136">返される行の数はデータベース内の実際のデータによって異なるため、データベースから読み込まれるデータの量、結果によってどの程度のメモリが使用されるか、およびこれらの結果を処理するときに生成される追加の負荷 (ネットワーク経由でユーザーブラウザーに送信するなど) を知ることはできません。</span><span class="sxs-lookup"><span data-stu-id="9808f-136">Since the number of rows returned depends on actual data in your database, it's impossible to know how much data will be loaded from the database, how much memory will be taken up by the results, and how much additional load will be generated when processing these results (e.g. by sending them to a user browser over the network).</span></span> <span data-ttu-id="9808f-137">とてもでは、テストデータベースにはほとんどのデータが含まれていないため、テスト中にすべて正常に機能しますが、クエリが実際のデータで実行を開始したときにパフォーマンスの問題が突然表示され、多くの行が返されます。</span><span class="sxs-lookup"><span data-stu-id="9808f-137">Crucially, test databases frequently contain little data, so that everything works well while testing, but performance problems suddenly appear when the query starts running on real-world data and many rows are returned.</span></span>

<span data-ttu-id="9808f-138">結果として、通常、結果の数を制限することになります。</span><span class="sxs-lookup"><span data-stu-id="9808f-138">As a result, it's usually worth giving thought to limiting the number of results:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#Limit25)]

<span data-ttu-id="9808f-139">少なくとも、データベースにより多くの行が存在する可能性があることを示すメッセージが UI に表示される場合があります (他の方法でも取得できます)。</span><span class="sxs-lookup"><span data-stu-id="9808f-139">At a minimum, your UI could show a message indicating that more rows may exist in the database (and allow retrieving them in some other manner).</span></span> <span data-ttu-id="9808f-140">本格的なソリューションでは、 *ページング* を実装します。 UI では一度に特定の数の行のみが表示され、ユーザーは必要に応じて次のページに進むことができます。通常、この操作では、 <xref:System.Linq.Enumerable.Take%2A> 演算子と演算子を組み合わせて、 <xref:System.Linq.Enumerable.Skip%2A> 結果セット内の特定の範囲を選択します。</span><span class="sxs-lookup"><span data-stu-id="9808f-140">A full-blown solution would implement *paging*, where your UI only shows a certain number of rows at a time, and allow users to advance to the next page as needed; this typically combines the <xref:System.Linq.Enumerable.Take%2A> and <xref:System.Linq.Enumerable.Skip%2A> operators to select a specific range in the resultset each time.</span></span>

## <a name="avoid-cartesian-explosion-when-loading-related-entities"></a><span data-ttu-id="9808f-141">関連エンティティの読み込み時にデカルト爆発を回避する</span><span class="sxs-lookup"><span data-stu-id="9808f-141">Avoid cartesian explosion when loading related entities</span></span>

<span data-ttu-id="9808f-142">リレーショナル データベースの場合、単一クエリで JOIN を使用すると、関連するすべてのエンティティが読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="9808f-142">In relational databases, all related entities are loaded by introducing JOINs in single query.</span></span>

```sql
SELECT [b].[BlogId], [b].[OwnerId], [b].[Rating], [b].[Url], [p].[PostId], [p].[AuthorId], [p].[BlogId], [p].[Content], [p].[Rating], [p].[Title]
FROM [Blogs] AS [b]
LEFT JOIN [Post] AS [p] ON [b].[BlogId] = [p].[BlogId]
ORDER BY [b].[BlogId], [p].[PostId]
```

<span data-ttu-id="9808f-143">一般的なブログに複数の関連する投稿がある場合、これらの投稿の行によってブログの情報が複製されます。</span><span class="sxs-lookup"><span data-stu-id="9808f-143">If a typical blog has multiple related posts, rows for these posts will duplicate the blog's information.</span></span> <span data-ttu-id="9808f-144">この重複により、いわゆる "デカルト爆発" の問題が発生します。</span><span class="sxs-lookup"><span data-stu-id="9808f-144">This duplication leads to the so-called "cartesian explosion" problem.</span></span> <span data-ttu-id="9808f-145">さらに一対多リレーションシップが読み込まれると、重複するデータの量が増加し、アプリケーションのパフォーマンスに悪影響を及ぼす可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9808f-145">As more one-to-many relationships are loaded, the amount of duplicated data may grow and adversely affect the performance of your application.</span></span>

<span data-ttu-id="9808f-146">EF では、"split queries" を使用してこの影響を回避できます。これにより、個別のクエリを介して関連エンティティが読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="9808f-146">EF allows avoiding this effect via the use of "split queries", which load the related entities via separate queries.</span></span> <span data-ttu-id="9808f-147">詳細については、 [split と single クエリに関するドキュメント](xref:core/querying/single-split-queries)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9808f-147">For more information, read [the documentation on split and single queries](xref:core/querying/single-split-queries).</span></span>

> [!NOTE]
> <span data-ttu-id="9808f-148">[分割クエリ](xref:core/querying/single-split-queries)の現在の実装では、各クエリに対してラウンドトリップを実行します。</span><span class="sxs-lookup"><span data-stu-id="9808f-148">The current implementation of [split queries](xref:core/querying/single-split-queries) executes a roundtrip for each query.</span></span> <span data-ttu-id="9808f-149">今後、この機能強化を予定しており、すべてのクエリを1回のラウンドトリップで実行します。</span><span class="sxs-lookup"><span data-stu-id="9808f-149">We plan to improve this in the future, and execute all queries in a single roundtrip.</span></span>

## <a name="load-related-entities-eagerly-when-possible"></a><span data-ttu-id="9808f-150">可能な場合は、関連エンティティの集中的を読み込む</span><span class="sxs-lookup"><span data-stu-id="9808f-150">Load related entities eagerly when possible</span></span>

<span data-ttu-id="9808f-151">このセクションを続行する前に [、関連エンティティの専用ページ](xref:core/querying/related-data) を読むことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="9808f-151">It's recommended to read [the dedicated page on related entities](xref:core/querying/related-data) before continuing with this section.</span></span>

<span data-ttu-id="9808f-152">関連エンティティを扱うときは、通常、読み込む必要があることを事前に把握しています。一般的な例として、特定の一連のブログとすべての投稿が読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="9808f-152">When dealing with related entities, we usually know in advance what we need to load: a typical example would be loading a certain set of Blogs, along with all their Posts.</span></span> <span data-ttu-id="9808f-153">これらのシナリオでは、常に [一括読み込み](xref:core/querying/related-data/eager)を使用することをお勧めします。これにより、EF が1つのラウンドトリップで必要なすべてのデータをフェッチできるようになります。</span><span class="sxs-lookup"><span data-stu-id="9808f-153">In these scenarios, it is always better to use [eager loading](xref:core/querying/related-data/eager), so that EF can fetch all the required data in one roundtrip.</span></span> <span data-ttu-id="9808f-154">EF Core 5.0 で導入されたフィルターされた [インクルード](xref:core/querying/related-data/eager#filtered-include) 機能では、読み込みプロセスを集中的に維持し、1回のラウンドトリップで取り上げことができるように、読み込む関連エンティティを制限することもできます。</span><span class="sxs-lookup"><span data-stu-id="9808f-154">The [filtered include](xref:core/querying/related-data/eager#filtered-include) feature, introduced in EF Core 5.0, also allows you to limit which related entities you'd like to load, while keeping the loading process eager and therefore doable in a single roundtrip:</span></span>

[!code-csharp[Main](../../../samples/core/Querying/RelatedData/Program.cs#FilteredInclude)]

<span data-ttu-id="9808f-155">他のシナリオでは、プリンシパルエンティティを取得する前に、どの関連エンティティが必要になるかわからない場合があります。</span><span class="sxs-lookup"><span data-stu-id="9808f-155">In other scenarios, we may not know which related entity we're going to need before we get its principal entity.</span></span> <span data-ttu-id="9808f-156">たとえば、いくつかのブログを読み込んだときに、そのブログの投稿に関心があるかどうかを知るために、他のデータソース (場合によっては webservice) を参照することが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="9808f-156">For example, when loading some Blog, we may need to consult some other data source - possibly a webservice - in order to know whether we're interested in that Blog's Posts.</span></span> <span data-ttu-id="9808f-157">このような場合は、 [明示的](xref:core/querying/related-data/explicit) または [遅延](xref:core/querying/related-data/lazy) 読み込みを使用して関連エンティティを個別に取得し、ブログの投稿のナビゲーションを設定できます。</span><span class="sxs-lookup"><span data-stu-id="9808f-157">In these cases, [explicit](xref:core/querying/related-data/explicit) or [lazy](xref:core/querying/related-data/lazy) loading can be used to fetch related entities separately, and populate the Blog's Posts navigation.</span></span> <span data-ttu-id="9808f-158">これらの方法はあまり使用されないため、データベースへの追加のラウンドトリップが必要であることに注意してください。これは、速度の低下の原因になります。特定のシナリオによっては、追加のラウンドトリップを実行するだけでなく、必要な投稿だけを選択的に取得するよりも、常にすべての投稿を読み込む方が効率的です。</span><span class="sxs-lookup"><span data-stu-id="9808f-158">Note that since these methods aren't eager, they require additional roundtrips to the database, which is source of slowdown; depending on your specific scenario, it may be more efficient to just always load all Posts, rather than to execute the additional roundtrips and selectively get only the Posts you need.</span></span>

### <a name="beware-of-lazy-loading"></a><span data-ttu-id="9808f-159">遅延読み込みに注意してください</span><span class="sxs-lookup"><span data-stu-id="9808f-159">Beware of lazy loading</span></span>

<span data-ttu-id="9808f-160">[遅延読み込み](xref:core/querying/related-data/lazy) は、コードによってアクセスされるときにデータベースから関連エンティティが自動的に読み込まれる EF Core ため、データベースロジックを記述する非常に便利な方法のように思われます。</span><span class="sxs-lookup"><span data-stu-id="9808f-160">[Lazy loading](xref:core/querying/related-data/lazy) often seems like a very useful way to write database logic, since EF Core automatically loads related entities from the database as they are accessed by your code.</span></span> <span data-ttu-id="9808f-161">これにより、必要のない ( [明示的な読み込み](xref:core/querying/related-data/explicit)などの) 関連エンティティが読み込まれなくなるため、プログラマは関連エンティティを完全に処理する必要がなくなります。</span><span class="sxs-lookup"><span data-stu-id="9808f-161">This avoids loading related entities that aren't needed (like [explicit loading](xref:core/querying/related-data/explicit)), and seemingly frees the programmer from having to deal with related entities altogether.</span></span> <span data-ttu-id="9808f-162">ただし、遅延読み込みは特に不要な余分なラウンドトリップを生成することが原因で、アプリケーションの処理速度が低下する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9808f-162">However, lazy loading is particularly prone for producing unneeded extra roundtrips which can slow the application.</span></span>

<span data-ttu-id="9808f-163">以下、具体例に沿って説明します。</span><span class="sxs-lookup"><span data-stu-id="9808f-163">Consider the following:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#NPlusOne)]

<span data-ttu-id="9808f-164">この一見無害なコードは、すべてのブログとその投稿を反復処理して、それを印刷します。EF Core の [ステートメントログ記録](xref:core/logging-events-diagnostics/index) をオンにすると、次のようになります。</span><span class="sxs-lookup"><span data-stu-id="9808f-164">This seemingly innocent piece of code iterates through all the blogs and their posts, printing them out. Turning on EF Core's [statement logging](xref:core/logging-events-diagnostics/index) reveals the following:</span></span>

```console
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (1ms) [Parameters=[], CommandType='Text', CommandTimeout='30']
      SELECT [b].[BlogId], [b].[Rating], [b].[Url]
      FROM [Blogs] AS [b]
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (5ms) [Parameters=[@__p_0='1'], CommandType='Text', CommandTimeout='30']
      SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Title]
      FROM [Post] AS [p]
      WHERE [p].[BlogId] = @__p_0
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (1ms) [Parameters=[@__p_0='2'], CommandType='Text', CommandTimeout='30']
      SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Title]
      FROM [Post] AS [p]
      WHERE [p].[BlogId] = @__p_0
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (1ms) [Parameters=[@__p_0='3'], CommandType='Text', CommandTimeout='30']
      SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Title]
      FROM [Post] AS [p]
      WHERE [p].[BlogId] = @__p_0

... and so on
```

<span data-ttu-id="9808f-165">どうなっているのでしょうか?</span><span class="sxs-lookup"><span data-stu-id="9808f-165">What's going on here?</span></span> <span data-ttu-id="9808f-166">上記の単純なループに対してこれらのクエリがすべて送信されるのはなぜですか。</span><span class="sxs-lookup"><span data-stu-id="9808f-166">Why are all these queries being sent for the simple loops above?</span></span> <span data-ttu-id="9808f-167">遅延読み込みを使用すると、投稿のプロパティにアクセスしたときにのみ、ブログの投稿が読み込まれます。その結果、内部 foreach の各反復処理では、独自のラウンドトリップで、追加のデータベースクエリがトリガーされます。</span><span class="sxs-lookup"><span data-stu-id="9808f-167">With lazy loading, a Blog's Posts are only (lazily) loaded when its Posts property is accessed; as a result, each iteration in the inner foreach triggers an additional database query, in its own roundtrip.</span></span> <span data-ttu-id="9808f-168">その結果、最初のクエリによってすべてのブログが読み込まれた後、 *ブログごと* に別のクエリが作成され、すべての投稿が読み込まれます。これは、 *N + 1* の問題と呼ばれることもあり、非常に重大なパフォーマンスの問題が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9808f-168">As a result, after the initial query loading all the blogs, we then have another query *per blog*, loading all its posts; this is sometimes called the *N+1* problem, and it can cause very significant performance issues.</span></span>

<span data-ttu-id="9808f-169">ブログの投稿をすべて必要としている場合は、代わりに一括読み込みを使用するのが理にかなっています。</span><span class="sxs-lookup"><span data-stu-id="9808f-169">Assuming we're going to need all of the blogs' posts, it makes sense to use eager loading here instead.</span></span> <span data-ttu-id="9808f-170">[Include](xref:core/querying/related-data/eager#eager-loading)演算子を使用して読み込みを実行できますが、必要なのはブログの url だけであるため、必要なもののみを[読み込む](xref:core/performance/efficient-updating#project-only-properties-you-need)必要があるためです。</span><span class="sxs-lookup"><span data-stu-id="9808f-170">We can use the [Include](xref:core/querying/related-data/eager#eager-loading) operator to perform the loading, but since we only need the Blogs' URLs (and we should only [load what's needed](xref:core/performance/efficient-updating#project-only-properties-you-need)).</span></span> <span data-ttu-id="9808f-171">そのため、代わりに射影を使用します。</span><span class="sxs-lookup"><span data-stu-id="9808f-171">So we'll use a projection instead:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#EagerlyLoadRelatedAndProject)]

<span data-ttu-id="9808f-172">これにより、すべてのブログとその投稿を1つのクエリで取得 EF Core ようになります。</span><span class="sxs-lookup"><span data-stu-id="9808f-172">This will make EF Core fetch all the Blogs - along with their Posts - in a single query.</span></span> <span data-ttu-id="9808f-173">場合によっては、 [分割クエリ](xref:core/querying/single-split-queries)を使用してデカルト爆発効果を回避すると便利な場合もあります。</span><span class="sxs-lookup"><span data-stu-id="9808f-173">In some cases, it may also be useful to avoid cartesian explosion effects by using [split queries](xref:core/querying/single-split-queries).</span></span>

> [!WARNING]
> <span data-ttu-id="9808f-174">遅延読み込みでは、N + 1 問題を誤ってトリガーすることが非常に簡単であるため、この問題を回避することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="9808f-174">Because lazy loading makes it extremely easy to inadvertently trigger the N+1 problem, it is recommended to avoid it.</span></span> <span data-ttu-id="9808f-175">一括読み込みまたは明示的な読み込みでは、データベースのラウンドトリップが発生したときにソースコードが非常に明確になります。</span><span class="sxs-lookup"><span data-stu-id="9808f-175">Eager or explicit loading make it very clear in the source code when a database roundtrip occurs.</span></span>

## <a name="buffering-and-streaming"></a><span data-ttu-id="9808f-176">バッファリングとストリーミング</span><span class="sxs-lookup"><span data-stu-id="9808f-176">Buffering and streaming</span></span>

<span data-ttu-id="9808f-177">バッファリングとは、すべてのクエリ結果をメモリに読み込むことを指します。一方、ストリーミングでは、EF はアプリケーションを毎回1つの結果にすることを意味し、メモリ内に結果セット全体が含まれることはありません。</span><span class="sxs-lookup"><span data-stu-id="9808f-177">Buffering refers to loading all your query results into memory, whereas streaming means that that EF hands the application a single result each time, never containing the entire resultset in memory.</span></span> <span data-ttu-id="9808f-178">原則として、ストリーミングクエリのメモリ要件は固定されています。クエリが1行または1000を返すかどうかは同じです。一方、バッファリングクエリでは、より多くのメモリが必要になるため、より多くの行が返されます。</span><span class="sxs-lookup"><span data-stu-id="9808f-178">In principle, the memory requirements of a streaming query are fixed - they are the same whether the query returns 1 row or 1000; a buffering query, on the other hand, requires more memory the more rows are returned.</span></span> <span data-ttu-id="9808f-179">大きな結果セットを生成するクエリの場合、これは重要なパフォーマンス要因になることがあります。</span><span class="sxs-lookup"><span data-stu-id="9808f-179">For queries that result large resultsets, this can be an important performance factor.</span></span>

<span data-ttu-id="9808f-180">クエリのバッファーまたはストリームがどのように評価されるかによって異なります。</span><span class="sxs-lookup"><span data-stu-id="9808f-180">Whether a query buffers or streams depends on how it is evaluated:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#BufferingAndStreaming)]

<span data-ttu-id="9808f-181">クエリから返される結果がわずかである場合は、これについて心配する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="9808f-181">If your queries return just a few results, then you probably don't have to worry about this.</span></span> <span data-ttu-id="9808f-182">ただし、クエリで大量の行が返される可能性がある場合は、バッファー処理ではなくストリーミングすることを検討してください。</span><span class="sxs-lookup"><span data-stu-id="9808f-182">However, if your query might return large numbers of rows, it's worth giving thought to streaming instead of buffering.</span></span>

> [!NOTE]
> <span data-ttu-id="9808f-183"><xref:System.Linq.Enumerable.ToList%2A>結果に対して別の LINQ 演算子を使用する場合は、またはを使用しない <xref:System.Linq.Enumerable.ToArray%2A> でください。これにより、すべての結果が不必要にメモリにバッファーされます。</span><span class="sxs-lookup"><span data-stu-id="9808f-183">Avoid using <xref:System.Linq.Enumerable.ToList%2A> or <xref:System.Linq.Enumerable.ToArray%2A> if you intend to use another LINQ operator on the result - this will needlessly buffer all results into memory.</span></span> <span data-ttu-id="9808f-184">代わりに、<xref:System.Linq.Enumerable.AsEnumerable%2A> を使用してください。</span><span class="sxs-lookup"><span data-stu-id="9808f-184">Use <xref:System.Linq.Enumerable.AsEnumerable%2A> instead.</span></span>

### <a name="internal-buffering-by-ef"></a><span data-ttu-id="9808f-185">EF による内部バッファリング</span><span class="sxs-lookup"><span data-stu-id="9808f-185">Internal buffering by EF</span></span>

<span data-ttu-id="9808f-186">特定の状況では、EF はクエリの評価方法に関係なく、内部的に結果セットをバッファーします。</span><span class="sxs-lookup"><span data-stu-id="9808f-186">In certain situations, EF will itself buffer the resultset internally, regardless of how you evaluate your query.</span></span> <span data-ttu-id="9808f-187">この問題が発生する2つのケースを次に示します。</span><span class="sxs-lookup"><span data-stu-id="9808f-187">The two cases where this happens are:</span></span>

* <span data-ttu-id="9808f-188">再試行の実行戦略が適用されている場合。</span><span class="sxs-lookup"><span data-stu-id="9808f-188">When a retrying execution strategy is in place.</span></span> <span data-ttu-id="9808f-189">これは、後でクエリが再試行された場合に同じ結果が返されるようにするために行われます。</span><span class="sxs-lookup"><span data-stu-id="9808f-189">This is done to make sure the same results are returned if the query is retried later.</span></span>
* <span data-ttu-id="9808f-190">[Split クエリ](xref:core/querying/single-split-queries)を使用すると、SQL SERVER で MARS が有効になっていない限り、最後のクエリ以外のすべての結果セットがバッファーされます。</span><span class="sxs-lookup"><span data-stu-id="9808f-190">When [split query](xref:core/querying/single-split-queries) is used, the resultsets of all but the last query are buffered - unless MARS is enabled on SQL Server.</span></span> <span data-ttu-id="9808f-191">これは、通常、複数のクエリの結果セットを同時にアクティブにすることができないためです。</span><span class="sxs-lookup"><span data-stu-id="9808f-191">This is because it is usually impossible to have multiple query resultsets active at the same time.</span></span>

<span data-ttu-id="9808f-192">この内部バッファリングは、LINQ 演算子を介して発生するバッファリングに加えて発生することに注意してください。</span><span class="sxs-lookup"><span data-stu-id="9808f-192">Note that this internal buffering occurs in addition to any buffering you cause via LINQ operators.</span></span> <span data-ttu-id="9808f-193">たとえば、クエリでを使用し、再試行中の実行戦略を設定した場合、 <xref:System.Linq.Enumerable.ToList%2A> 結果セットは *2 回*(EF によって内部的に1回、によって) メモリに読み込まれ <xref:System.Linq.Enumerable.ToList%2A> ます。</span><span class="sxs-lookup"><span data-stu-id="9808f-193">For example, if you use <xref:System.Linq.Enumerable.ToList%2A> on a query and a retrying execution strategy is in place, the resultset is loaded into memory *twice*: once internally by EF, and once by <xref:System.Linq.Enumerable.ToList%2A>.</span></span>

## <a name="tracking-no-tracking-and-identity-resolution"></a><span data-ttu-id="9808f-194">追跡、追跡なし、および id 解決</span><span class="sxs-lookup"><span data-stu-id="9808f-194">Tracking, no-tracking and identity resolution</span></span>

<span data-ttu-id="9808f-195">このセクションを続行する前に [、追跡と追跡なしの専用ページ](xref:core/querying/tracking) を読むことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="9808f-195">It's recommended to read [the dedicated page on tracking and no-tracking](xref:core/querying/tracking) before continuing with this section.</span></span>

<span data-ttu-id="9808f-196">EF は、が呼び出されたときに、エンティティインスタンスの変更が検出され、永続化されるように、既定でエンティティインスタンスを追跡 <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> します。</span><span class="sxs-lookup"><span data-stu-id="9808f-196">EF tracks entity instances by default, so that changes on them are detected and persisted when <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> is called.</span></span> <span data-ttu-id="9808f-197">追跡クエリのもう1つの影響として、EF では、インスタンスが既にデータ用に読み込まれているかどうかが検出され、新しいインスタンスを返さずに、追跡対象のインスタンスが自動的に返されます。これは、 *id 解決* と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="9808f-197">Another effect of tracking queries is that EF detects if an instance has already been loaded for your data, and will automatically return that tracked instance rather than returning a new one; this is called *identity resolution*.</span></span> <span data-ttu-id="9808f-198">パフォーマンスの観点から見ると、変更の追跡は次のことを意味します。</span><span class="sxs-lookup"><span data-stu-id="9808f-198">From a performance perspective, change tracking means the following:</span></span>

* <span data-ttu-id="9808f-199">EF は、内部的に追跡対象インスタンスのディクショナリを保持します。</span><span class="sxs-lookup"><span data-stu-id="9808f-199">EF internally maintains a dictionary of tracked instances.</span></span> <span data-ttu-id="9808f-200">新しいデータが読み込まれると、EF は、そのエンティティのキー (id 解決) に対して既にインスタンスが追跡されているかどうかを確認するために、ディクショナリをチェックします。</span><span class="sxs-lookup"><span data-stu-id="9808f-200">When new data is loaded, EF checks the dictionary to see if an instance is already tracked for that entity's key (identity resolution).</span></span> <span data-ttu-id="9808f-201">ディクショナリのメンテナンスと参照は、クエリの結果を読み込むときに時間がかかります。</span><span class="sxs-lookup"><span data-stu-id="9808f-201">The dictionary maintenance and lookups take up some time when loading the query's results.</span></span>
* <span data-ttu-id="9808f-202">読み込まれたインスタンスをアプリケーションに渡す前に、EF はインスタンスを *スナップショット* に保持し、スナップショットを内部に保持します。</span><span class="sxs-lookup"><span data-stu-id="9808f-202">Before handing a loaded instance to the application, EF *snapshots* that instance and keeps the snapshot internally.</span></span> <span data-ttu-id="9808f-203">が呼び出されると、 <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> アプリケーションのインスタンスとスナップショットが比較され、永続化される変更が検出されます。</span><span class="sxs-lookup"><span data-stu-id="9808f-203">When <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> is called, the application's instance is compared with the snapshot to discover the changes to be persisted.</span></span> <span data-ttu-id="9808f-204">スナップショットはより多くのメモリを占有し、スナップショットプロセス自体には時間がかかります。場合によっては、 [値の比較](xref:core/modeling/value-comparers)によって、より効率的なスナップショット動作を指定したり、変更追跡プロキシを使用してスナップショットプロセスを完全にバイパスしたりすることができます (ただし、これには独自の欠点があります)。</span><span class="sxs-lookup"><span data-stu-id="9808f-204">The snapshot takes up more memory, and the snapshotting process itself takes time; it's sometimes possible to specify different, possibly more efficient snapshotting behavior via [value comparers](xref:core/modeling/value-comparers), or to use change-tracking proxies to bypass the snapshotting process altogether (though that comes with its own set of disadvantages).</span></span>

<span data-ttu-id="9808f-205">変更がデータベースに保存されない読み取り専用のシナリオでは、 [追跡なしのクエリ](xref:core/querying/tracking#no-tracking-queries)を使用して上記のオーバーヘッドを回避できます。</span><span class="sxs-lookup"><span data-stu-id="9808f-205">In read-only scenarios where changes aren't saved back to the database, the above overheads can be avoided by using [no-tracking queries](xref:core/querying/tracking#no-tracking-queries).</span></span> <span data-ttu-id="9808f-206">ただし、追跡なしのクエリは id 解決を実行しないため、他の複数の読み込まれた行によって参照されているデータベース行は、異なるインスタンスとして具体化されます。</span><span class="sxs-lookup"><span data-stu-id="9808f-206">However, since no-tracking queries do not perform identity resolution, a database row which is referenced by multiple other loaded rows will be materialized as as different instances.</span></span>

<span data-ttu-id="9808f-207">例として、データベースから多数の投稿を読み込んでいることと、各投稿で参照されているブログを読み込んでいるとします。</span><span class="sxs-lookup"><span data-stu-id="9808f-207">To illustrate, assume we are loading a large number of Posts from the database, as well as the Blog referenced by each Post.</span></span> <span data-ttu-id="9808f-208">同じブログを参照するために100の投稿が発生した場合、追跡クエリは id 解決によってこれを検出し、すべての Post インスタンスは同じ重複除去されていないブログインスタンスを参照します。</span><span class="sxs-lookup"><span data-stu-id="9808f-208">If 100 Posts happen to reference the same Blog, a tracking query detects this via identity resolution, and all Post instances will refer the same de-duplicated Blog instance.</span></span> <span data-ttu-id="9808f-209">これに対して、非追跡クエリは同じブログ100回を複製し、それに応じてアプリケーションコードを記述する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9808f-209">A no-tracking query, in contrast, duplicates the same Blog 100 times - and application code must be written accordingly.</span></span>

<span data-ttu-id="9808f-210">次に示すのは、クエリの追跡と追跡なしの動作を比較するベンチマークの結果であり、20件の投稿を含む10個のブログを読み込んでいます。</span><span class="sxs-lookup"><span data-stu-id="9808f-210">Here are the results for a benchmark comparing tracking vs. no-tracking behavior for a query loading 10 Blogs with 20 Posts each.</span></span> <span data-ttu-id="9808f-211">[ソースコードはこちらで入手でき](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/QueryTrackingBehavior.cs)ます。独自の測定値のベースとして自由に使用できます。</span><span class="sxs-lookup"><span data-stu-id="9808f-211">[The source code is available here](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/QueryTrackingBehavior.cs), feel free to use it as a basis for your own measurements.</span></span>

|       <span data-ttu-id="9808f-212">Method</span><span class="sxs-lookup"><span data-stu-id="9808f-212">Method</span></span> | <span data-ttu-id="9808f-213">NumBlogs</span><span class="sxs-lookup"><span data-stu-id="9808f-213">NumBlogs</span></span> | <span data-ttu-id="9808f-214">NumPostsPerBlog</span><span class="sxs-lookup"><span data-stu-id="9808f-214">NumPostsPerBlog</span></span> |       <span data-ttu-id="9808f-215">平均</span><span class="sxs-lookup"><span data-stu-id="9808f-215">Mean</span></span> |    <span data-ttu-id="9808f-216">エラー</span><span class="sxs-lookup"><span data-stu-id="9808f-216">Error</span></span> |   <span data-ttu-id="9808f-217">StdDev</span><span class="sxs-lookup"><span data-stu-id="9808f-217">StdDev</span></span> |     <span data-ttu-id="9808f-218">中央値</span><span class="sxs-lookup"><span data-stu-id="9808f-218">Median</span></span> | <span data-ttu-id="9808f-219">比率</span><span class="sxs-lookup"><span data-stu-id="9808f-219">Ratio</span></span> | <span data-ttu-id="9808f-220">RatioSD</span><span class="sxs-lookup"><span data-stu-id="9808f-220">RatioSD</span></span> |   <span data-ttu-id="9808f-221">Gen 0</span><span class="sxs-lookup"><span data-stu-id="9808f-221">Gen 0</span></span> |   <span data-ttu-id="9808f-222">Gen 1</span><span class="sxs-lookup"><span data-stu-id="9808f-222">Gen 1</span></span> | <span data-ttu-id="9808f-223">Gen 2</span><span class="sxs-lookup"><span data-stu-id="9808f-223">Gen 2</span></span> | <span data-ttu-id="9808f-224">Allocated</span><span class="sxs-lookup"><span data-stu-id="9808f-224">Allocated</span></span> |
|------------- |--------- |---------------- |-----------:|---------:|---------:|-----------:|------:|--------:|--------:|--------:|------:|----------:|
|   <span data-ttu-id="9808f-225">AsTracking</span><span class="sxs-lookup"><span data-stu-id="9808f-225">AsTracking</span></span> |       <span data-ttu-id="9808f-226">10</span><span class="sxs-lookup"><span data-stu-id="9808f-226">10</span></span> |              <span data-ttu-id="9808f-227">20</span><span class="sxs-lookup"><span data-stu-id="9808f-227">20</span></span> | <span data-ttu-id="9808f-228">1414.7 us</span><span class="sxs-lookup"><span data-stu-id="9808f-228">1,414.7 us</span></span> | <span data-ttu-id="9808f-229">27.20 us</span><span class="sxs-lookup"><span data-stu-id="9808f-229">27.20 us</span></span> | <span data-ttu-id="9808f-230">45.44 us</span><span class="sxs-lookup"><span data-stu-id="9808f-230">45.44 us</span></span> | <span data-ttu-id="9808f-231">1405.5 us</span><span class="sxs-lookup"><span data-stu-id="9808f-231">1,405.5 us</span></span> |  <span data-ttu-id="9808f-232">1.00</span><span class="sxs-lookup"><span data-stu-id="9808f-232">1.00</span></span> |    <span data-ttu-id="9808f-233">0.00</span><span class="sxs-lookup"><span data-stu-id="9808f-233">0.00</span></span> | <span data-ttu-id="9808f-234">60.5469</span><span class="sxs-lookup"><span data-stu-id="9808f-234">60.5469</span></span> | <span data-ttu-id="9808f-235">13.6719</span><span class="sxs-lookup"><span data-stu-id="9808f-235">13.6719</span></span> |     - | <span data-ttu-id="9808f-236">380.11 KB</span><span class="sxs-lookup"><span data-stu-id="9808f-236">380.11 KB</span></span> |
| <span data-ttu-id="9808f-237">AsNoTracking</span><span class="sxs-lookup"><span data-stu-id="9808f-237">AsNoTracking</span></span> |       <span data-ttu-id="9808f-238">10</span><span class="sxs-lookup"><span data-stu-id="9808f-238">10</span></span> |              <span data-ttu-id="9808f-239">20</span><span class="sxs-lookup"><span data-stu-id="9808f-239">20</span></span> |   <span data-ttu-id="9808f-240">993.3 us</span><span class="sxs-lookup"><span data-stu-id="9808f-240">993.3 us</span></span> | <span data-ttu-id="9808f-241">24.04 us</span><span class="sxs-lookup"><span data-stu-id="9808f-241">24.04 us</span></span> | <span data-ttu-id="9808f-242">65.40 us</span><span class="sxs-lookup"><span data-stu-id="9808f-242">65.40 us</span></span> |   <span data-ttu-id="9808f-243">966.2 us</span><span class="sxs-lookup"><span data-stu-id="9808f-243">966.2 us</span></span> |  <span data-ttu-id="9808f-244">0.71</span><span class="sxs-lookup"><span data-stu-id="9808f-244">0.71</span></span> |    <span data-ttu-id="9808f-245">0.05</span><span class="sxs-lookup"><span data-stu-id="9808f-245">0.05</span></span> | <span data-ttu-id="9808f-246">37.1094</span><span class="sxs-lookup"><span data-stu-id="9808f-246">37.1094</span></span> |  <span data-ttu-id="9808f-247">6.8359</span><span class="sxs-lookup"><span data-stu-id="9808f-247">6.8359</span></span> |     - | <span data-ttu-id="9808f-248">232.89 KB</span><span class="sxs-lookup"><span data-stu-id="9808f-248">232.89 KB</span></span> |

<span data-ttu-id="9808f-249">最後に、追跡なしのクエリを使用し、返されたインスタンスをコンテキストにアタッチして、変更を行うかを指定することによって、変更の追跡のオーバーヘッドなしに更新を実行することができます。</span><span class="sxs-lookup"><span data-stu-id="9808f-249">Finally, it is possible to perform updates without the overhead of change tracking, by utilizing a no-tracking query and then attaching the returned instance to the context, specifying which changes are to be made.</span></span> <span data-ttu-id="9808f-250">これにより、変更の追跡の負荷が EF からユーザーに転送されます。また、プロファイルまたはベンチマークによって変更追跡のオーバーヘッドが許容されない場合にのみ、この作業を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="9808f-250">This transfers the burden of change tracking from EF to the user, and should only be attempted if the change tracking overhead has been shown to be unacceptable via profiling or benchmarking.</span></span>

## <a name="using-raw-sql"></a><span data-ttu-id="9808f-251">生の SQL の使用</span><span class="sxs-lookup"><span data-stu-id="9808f-251">Using raw SQL</span></span>

<span data-ttu-id="9808f-252">場合によっては、クエリに対してより最適化された SQL が存在し、EF では生成されません。</span><span class="sxs-lookup"><span data-stu-id="9808f-252">In some cases, more optimized SQL exists for your query, which EF does not generate.</span></span> <span data-ttu-id="9808f-253">これは、SQL コンストラクトが、サポートされていないデータベースに固有の拡張機能である場合、または EF がまだ変換していない場合にのみ発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9808f-253">This can happen when the SQL construct is an extension specific to your database that's unsupported, or simply because EF does not translate to it yet.</span></span> <span data-ttu-id="9808f-254">このような場合、手動で SQL を記述することでパフォーマンスを大幅に向上させることができ、EF ではこれを行うためのいくつかの方法がサポートされています。</span><span class="sxs-lookup"><span data-stu-id="9808f-254">In these cases, writing SQL by hand can provide a substantial performance boost, and EF supports several ways to do this.</span></span>

* <span data-ttu-id="9808f-255">生の SQL は、などの [クエリで直接](xref:core/querying/raw-sql)使用します <xref:Microsoft.EntityFrameworkCore.RelationalQueryableExtensions.FromSqlRaw%2A> 。</span><span class="sxs-lookup"><span data-stu-id="9808f-255">Use raw SQL [directly in your query](xref:core/querying/raw-sql), e.g. via <xref:Microsoft.EntityFrameworkCore.RelationalQueryableExtensions.FromSqlRaw%2A>.</span></span> <span data-ttu-id="9808f-256">EF では、通常の LINQ クエリを使用して生の SQL を構成することもできます。これにより、未加工の SQL でクエリの一部だけを表現できます。</span><span class="sxs-lookup"><span data-stu-id="9808f-256">EF even lets you compose over the raw SQL with regular LINQ queries, allowing you to express only a part of the query in raw SQL.</span></span> <span data-ttu-id="9808f-257">これは、コードベースの1つのクエリで、生の SQL のみを使用する必要がある場合に適した手法です。</span><span class="sxs-lookup"><span data-stu-id="9808f-257">This is a good technique when the raw SQL only needs to be used in a single query in your codebase.</span></span>
* <span data-ttu-id="9808f-258">[ユーザー定義関数](xref:core/querying/database-functions)(UDF) を定義し、クエリからそれを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="9808f-258">Define a [user-defined function](xref:core/querying/database-functions) (UDF), and then call that from your queries.</span></span> <span data-ttu-id="9808f-259">5.0 以降、EF では、Udf が完全な結果セットを返すことができることに注意してください。これはテーブル値関数 (Tvf) と呼ばれています。また、を関数にマップして、別のテーブルと同じように表示することもでき `DbSet` ます。</span><span class="sxs-lookup"><span data-stu-id="9808f-259">Note that since 5.0, EF allows UDFs to return full resultsets - these are known as table-valued functions (TVFs) - and also allows mapping a `DbSet` to a function, making it look just like just another table.</span></span>
* <span data-ttu-id="9808f-260">クエリでデータベースビューとクエリを定義します。</span><span class="sxs-lookup"><span data-stu-id="9808f-260">Define a database view and query from it in your queries.</span></span> <span data-ttu-id="9808f-261">関数とは異なり、ビューではパラメーターを使用できないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="9808f-261">Note that unlike functions, views cannot accept parameters.</span></span>

> [!NOTE]
> <span data-ttu-id="9808f-262">通常、未加工の SQL は最後の手段として使用する必要があります。 EF が必要な SQL を生成できないことを確認した後、特定のクエリに対してパフォーマンスが重要であることを確認してください。</span><span class="sxs-lookup"><span data-stu-id="9808f-262">Raw SQL should generally be used as a last resort, after making sure that EF can't generate the SQL you want, and when performance is important enough for the given query to justify it.</span></span> <span data-ttu-id="9808f-263">生の SQL を使用すると、大幅なメンテナンスの欠点が生じます。</span><span class="sxs-lookup"><span data-stu-id="9808f-263">Using raw SQL brings considerable maintenance disadvantages.</span></span>

## <a name="asynchronous-programming"></a><span data-ttu-id="9808f-264">非同期プログラミング</span><span class="sxs-lookup"><span data-stu-id="9808f-264">Asynchronous programming</span></span>

<span data-ttu-id="9808f-265">一般的な規則として、アプリケーションをスケーラブルにするためには、同期型ではなく非同期 Api (など) を常に使用することが重要です <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChangesAsync%2A> <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> 。</span><span class="sxs-lookup"><span data-stu-id="9808f-265">As a general rule, in order for your application to be scalable, it's important to always use asynchronous APIs rather than synchronous one (e.g. <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChangesAsync%2A> rather than <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A>).</span></span> <span data-ttu-id="9808f-266">同期 Api は、データベース i/o が実行されている間、スレッドをブロックします。これにより、スレッドの必要性と発生する必要があるスレッドコンテキストスイッチの数が増加します。</span><span class="sxs-lookup"><span data-stu-id="9808f-266">Synchronous APIs block the thread for the duration of database I/O, increasing the need for threads and the number of thread context switches that must occur.</span></span>

<span data-ttu-id="9808f-267">詳細については、「 [非同期プログラミング](xref:core/miscellaneous/async)」のページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="9808f-267">For more information, see the page on [async programming](xref:core/miscellaneous/async).</span></span>

> [!WARNING]
> <span data-ttu-id="9808f-268">同一のアプリケーションに同期コードと非同期コードを混在させないでください。誤ってスレッドプール不足の問題が発生した場合は、非常に簡単にトリガーできます。</span><span class="sxs-lookup"><span data-stu-id="9808f-268">Avoid mixing synchronous and asynchronous code in the same application - it's very easy to inadvertently trigger subtle thread-pool starvation issues.</span></span>
