---
title: パフォーマンスの概要 - EF Core
description: Entity Framework Core を効率的に使用するためのパフォーマンス ガイド
author: roji
ms.date: 12/1/2020
uid: core/miscellaneous/performance/index
ms.openlocfilehash: 14400d81ea3c93e2ebf40e8e585a457abf31478f
ms.sourcegitcommit: 4860d036ea0fb392c28799907bcc924c987d2d7b
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/17/2020
ms.locfileid: "97657686"
---
# <a name="introduction-to-performance"></a><span data-ttu-id="06ec7-103">パフォーマンスの概要</span><span class="sxs-lookup"><span data-stu-id="06ec7-103">Introduction to Performance</span></span>

<span data-ttu-id="06ec7-104">データベースのパフォーマンスは、データベース、ネットワーク、データベース ドライバー、およびデータ アクセス層 (EF Core など) といったコンポーネントのスタック全体にまたがる、膨大で複雑なトピックです。</span><span class="sxs-lookup"><span data-stu-id="06ec7-104">Database performance is a vast and complex topic, spanning an entire stack of components: the database, networking, the database driver, and data access layers such as EF Core.</span></span> <span data-ttu-id="06ec7-105">上位層および O/RM (EF Core など) により、アプリケーションの開発を大幅に簡素化し、保守容易性を向上させることができますが、透過性が損なわれて、パフォーマンスに関する重大な内部的詳細 (実行中の SQL など) が隠されることがあります。</span><span class="sxs-lookup"><span data-stu-id="06ec7-105">While high-level layers and O/RMs such as EF Core considerably simplify application development and improve maintainability, they can sometimes be opaque, hiding performance-critical internal details such as the SQL being executed.</span></span> <span data-ttu-id="06ec7-106">このセクションでは、EF Core で優れたパフォーマンスを実現する方法の概要を示し、アプリケーションのパフォーマンスを低下させるおそれのある、よくある落とし穴を回避する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="06ec7-106">This section attempts to provide an overview of how to achieve good performance with EF Core, and how to avoid common pitfalls which can degrade application performance.</span></span>

## <a name="identify-bottlenecks-and-measure-measure-measure"></a><span data-ttu-id="06ec7-107">ボトルネックを特定し、徹底的に測定する</span><span class="sxs-lookup"><span data-stu-id="06ec7-107">Identify bottlenecks and measure, measure, measure</span></span>

<span data-ttu-id="06ec7-108">パフォーマンスについて常に言えることですが、問題を示すデータなしに性急に最適化を行わないようにすることが重要です。偉大な Donald Knuth 氏の言葉にあるとおり、"早まった最適化は諸悪の根源" です。</span><span class="sxs-lookup"><span data-stu-id="06ec7-108">As always with performance, it's important not to rush into optimization without data showing a problem; as the great Donald Knuth once said, "Premature optimization is the root of all evil".</span></span> <span data-ttu-id="06ec7-109">[パフォーマンス診断](xref:core/performance/performance-diagnosis)に関するセクションでは、アプリケーションでデータベース ロジックに時間が費やされている場所を把握するためのさまざまな方法と、問題のある特定の領域を特定する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="06ec7-109">The [performance diagnosis](xref:core/performance/performance-diagnosis) section discusses various ways to understand where your application is spending time in database logic, and how to pinpoint specific problematic areas.</span></span> <span data-ttu-id="06ec7-110">低速のクエリが特定されたら、解決策を検討できます。データベースにインデックスがないのでしょうか?</span><span class="sxs-lookup"><span data-stu-id="06ec7-110">Once a slow query has been identified, solutions can be considered: is your database missing an index?</span></span> <span data-ttu-id="06ec7-111">また、他のクエリ パターンを試してみる必要はあるでしょうか?</span><span class="sxs-lookup"><span data-stu-id="06ec7-111">Should you try out other querying patterns?</span></span>

<span data-ttu-id="06ec7-112">常にコードおよび可能な選択肢を自分でベンチマークします。パフォーマンス診断のセクションには、BenchmarkDotNet を使用したサンプル ベンチマークが含まれています。これは、独自のベンチマークのテンプレートとして使用できます。</span><span class="sxs-lookup"><span data-stu-id="06ec7-112">Always benchmark your code and possible alternatives yourself - the performance diagnosis section contains a sample benchmark with BenchmarkDotNet, which you can use as a template for your own benchmarks.</span></span> <span data-ttu-id="06ec7-113">一般的なパブリック ベンチマークが特定のユースケースにそのまま適用されるとは考えないでください。テーブル内のデータベースの待機時間、クエリの複雑さ、実際のデータ量など、さまざまな要因が、どのソリューションが最適かということに大きな影響を与える場合があります。</span><span class="sxs-lookup"><span data-stu-id="06ec7-113">Don't assume that general, public benchmarks apply as-is to your specific use-case; a variety of factors such as database latency, query complexity and actual data amounts in your tables can have a profound effect on which solution is best.</span></span> <span data-ttu-id="06ec7-114">たとえば、多くのパブリック ベンチマークは、データベースへの待機時間がほぼゼロの最適なネットワーク条件で、データベース側の処理 (またはディスク I/O) を必要としない非常に軽いクエリで実行されます。</span><span class="sxs-lookup"><span data-stu-id="06ec7-114">For example, many public benchmarks are carried out in ideal networking conditions, where latency to the database is almost zero, and with extremely light queries which hardly require any processing (or disk I/O) on the database side.</span></span> <span data-ttu-id="06ec7-115">これらは、さまざまなデータ アクセス層のランタイム オーバーヘッドを比較するのに役立ちますが、通常、これらの違いは実際のアプリケーションではごくわずかです。実際のアプリケーションでは、データベースによって実際の作業が実行され、データベースへの待機時間が重要なパフォーマンス要因となります。</span><span class="sxs-lookup"><span data-stu-id="06ec7-115">While these are valuable for comparing the runtime overheads of different data access layers, the differences they reveal usually prove to be negligible in a real-world application, where the database performs actual work and latency to the database is a significant perf factor.</span></span>

## <a name="aspects-of-data-access-performance"></a><span data-ttu-id="06ec7-116">データ アクセス パフォーマンスの側面</span><span class="sxs-lookup"><span data-stu-id="06ec7-116">Aspects of data access performance</span></span>

<span data-ttu-id="06ec7-117">全体的なデータ アクセス パフォーマンスは、次の広範なカテゴリに分類できます。</span><span class="sxs-lookup"><span data-stu-id="06ec7-117">Overall data access performance can be broken down into the following broad categories:</span></span>

* <span data-ttu-id="06ec7-118">**純粋なデータベース パフォーマンス**。</span><span class="sxs-lookup"><span data-stu-id="06ec7-118">**Pure database performance**.</span></span> <span data-ttu-id="06ec7-119">リレーショナル データベースでは、EF によって、アプリケーションの LINQ クエリが、データベースによって実行される SQL ステートメントに変換されます。これらの SQL ステートメント自体は、おおむね効率的に実行できます。</span><span class="sxs-lookup"><span data-stu-id="06ec7-119">With relational database, EF translates the application's LINQ queries into the SQL statements getting executed by the database; these SQL statements themselves can run more or less efficiently.</span></span> <span data-ttu-id="06ec7-120">適切な場所に適切なインデックスを使用すると、SQL のパフォーマンスを向上させることができます。また、LINQ クエリを再記述すると、EF によってより適切な SQL クエリが生成される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="06ec7-120">The right index in the right place can make a world of difference in SQL performance, or rewriting your LINQ query may make EF generate a better SQL query.</span></span>
* <span data-ttu-id="06ec7-121">**ネットワーク データ転送**。</span><span class="sxs-lookup"><span data-stu-id="06ec7-121">**Network data transfer**.</span></span> <span data-ttu-id="06ec7-122">ネットワーク システムと同様に、ネットワーク上でやり取りされるデータの量を制限することが重要です。</span><span class="sxs-lookup"><span data-stu-id="06ec7-122">As with any networking system, it's important to limit the amount of data going back and forth on the wire.</span></span> <span data-ttu-id="06ec7-123">これにより、実際に必要なデータのみを送信および読み込みできるようになります。また、関連エンティティを読み込むときに、いわゆる "デカルト爆発" 効果を回避できます。</span><span class="sxs-lookup"><span data-stu-id="06ec7-123">This covers making sure that you only send and load data which you're actually going to need, but also avoiding the so-called "cartesian explosion" effect when loading related entities.</span></span>
* <span data-ttu-id="06ec7-124">**ネットワーク ラウンドトリップ**。</span><span class="sxs-lookup"><span data-stu-id="06ec7-124">**Network roundtrips**.</span></span> <span data-ttu-id="06ec7-125">データベース内でクエリを実行するための時間は、アプリケーションとデータベースの間をパケットが行き来する時間のために短縮される可能性があるため、データのやり取りの量を超えてネットワーク ラウンドトリップが行われます。</span><span class="sxs-lookup"><span data-stu-id="06ec7-125">Beyond the amount of data going back and forth, the network roundtrips, since the time taken for a query to execute in the database can be dwarfed by the time packets travel back and forth between your application and your database.</span></span> <span data-ttu-id="06ec7-126">ラウンドトリップのオーバーヘッドは環境に大きく依存します。データベース サーバーが遠くなるほど、待機時間が長くなり、各ラウンドトリップのコストが増加します。</span><span class="sxs-lookup"><span data-stu-id="06ec7-126">Roundtrip overhead heavily depends on your environment; the further away your database server is, the high the latency and the costlier each roundtrip.</span></span> <span data-ttu-id="06ec7-127">クラウドの登場により、データベースからアプリケーションまでが遠くなり、実行するラウンドトリップが多すぎる "chatty" (頻繁な、饒舌な) アプリケーションのパフォーマンスが低下します。</span><span class="sxs-lookup"><span data-stu-id="06ec7-127">With the advent of the cloud, applications increasingly find themselves further away from the database, and "chatty" applications which perform too many roundtrips experience degraded performance.</span></span> <span data-ttu-id="06ec7-128">そのため、アプリケーションからデータベースに接続されるタイミング、実行されるラウンドトリップの回数、およびその数を最小限に抑えることができるかどうかを、正確に把握することが重要です。</span><span class="sxs-lookup"><span data-stu-id="06ec7-128">Therefore, it's important to understand exactly when your application contacts the database, how many roundtrips it performs, and whether that number can be minimized them.</span></span>
* <span data-ttu-id="06ec7-129">**EF ランタイム オーバーヘッド**。</span><span class="sxs-lookup"><span data-stu-id="06ec7-129">**EF runtime overhead**.</span></span> <span data-ttu-id="06ec7-130">最後に、EF 自体により、データベース操作にいくらかのランタイム オーバーヘッドが追加されます。たとえば、EF では LINQ から SQL にクエリをコンパイルする必要があります (通常は 1 回だけ実行します)。また、変更の追跡によって、いくらかのオーバーヘッドが追加されます (ただし、無効にすることもできます)。実際には、データベースでのクエリの実行時間とネットワーク待機時間が合計時間の大部分を占めるため、ほとんどの場合、実際のアプリケーションの EF オーバーヘッドはごくわずかになる可能性があります。ただし、オプションの内容と、いくつかの落とし穴を回避する方法を理解しておくことが重要です。</span><span class="sxs-lookup"><span data-stu-id="06ec7-130">Finally, EF itself adds some runtime overhead to database operations: EF needs to compile your queries from LINQ to SQL (although that should normally be done only once), change tracking adds some overhead (but can be disabled), etc. In practice, the EF overhead for real-world applications is likely to be negligible in most cases, as query execution time in the database and network latency dominate the total time; but it's important to understand what your options are and how to avoid some pitfalls.</span></span>

## <a name="know-whats-happening-under-the-hood"></a><span data-ttu-id="06ec7-131">内部で起こっている内容を把握する</span><span class="sxs-lookup"><span data-stu-id="06ec7-131">Know what's happening under the hood</span></span>

<span data-ttu-id="06ec7-132">EF を使用すると、開発者は SQL を生成し、結果を具体化し、その他のタスクを実行することで、ビジネス ロジックに専念できます。</span><span class="sxs-lookup"><span data-stu-id="06ec7-132">EF allows developers to concentrate on business logic by generating SQL, materializing results, and performing other tasks.</span></span> <span data-ttu-id="06ec7-133">また、レイヤーや抽象化と同様に、内部で起こっている内容 (実際に実行されている SQL クエリなど) が隠される傾向があります。</span><span class="sxs-lookup"><span data-stu-id="06ec7-133">Like any layer or abstraction, it also tends to hide what's happening under-the-hood, such as the actual SQL queries being executed.</span></span> <span data-ttu-id="06ec7-134">パフォーマンスは、すべてのアプリケーションの重要な側面であるとは限りませんが、それに該当するアプリケーションでは、EF によって実行されている内容を開発者が把握しておくことが重要です (出力方向の SQL クエリを調査する、ラウンドトリップを追跡して N+1 の問題が発生していないことを確認する、など)。</span><span class="sxs-lookup"><span data-stu-id="06ec7-134">Performance isn't necessarily a critical aspect of every application out there, but in applications where it is, it is vital that the developer understand what EF is doing for them: inspect outgoing SQL queries, follow roundtrips to make sure the N+1 problem isn't occurring, etc.</span></span>

## <a name="cache-outside-the-database"></a><span data-ttu-id="06ec7-135">データベースの外部でのキャッシュ</span><span class="sxs-lookup"><span data-stu-id="06ec7-135">Cache outside the database</span></span>

<span data-ttu-id="06ec7-136">最後に、データベースを操作する最も効率的な方法は、データベースをできる限り操作しないことです。</span><span class="sxs-lookup"><span data-stu-id="06ec7-136">Finally, the most efficient way to interact with a database, is to not interact with it at all.</span></span> <span data-ttu-id="06ec7-137">つまり、データベース アクセスがアプリケーションのパフォーマンスのボトルネックである場合は、要求を最小限に抑えるために、データベースの外部で特定の結果をキャッシュすると有用な可能性があります。</span><span class="sxs-lookup"><span data-stu-id="06ec7-137">In other words, if database access shows up as a performance bottleneck in your application, it may be worthwhile to cache certain results outside of the database, so as to minimize requests.</span></span> <span data-ttu-id="06ec7-138">キャッシュは複雑になりますが、これは拡張性の高いアプリケーションでは特に重要です。アプリケーション層は、負荷の増加に対応するためにサーバーを追加することで簡単に拡張できますが、データベース層のスケーリングは、通常、はるかに複雑になります。</span><span class="sxs-lookup"><span data-stu-id="06ec7-138">Although caching adds complexity, it is an especially crucial part of any scalable application: while the application tier can be easy scaled by adding additional servers to handle increased load, scaling the database tier is usually far more complicated.</span></span>
