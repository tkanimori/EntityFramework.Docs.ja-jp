---
title: クエリのしくみ - EF Core
author: rowanmiller
ms.author: divega
ms.date: 10/27/2016
ms.assetid: de2e34cd-659b-4cab-b5ed-7a979c6bf120
ms.technology: entity-framework-core
uid: core/querying/overview
ms.openlocfilehash: 1d28d215302625cf2b6788359527a93a77b7e9fd
ms.sourcegitcommit: bdd06c9a591ba5e6d6a3ec046c80de98f598f3f3
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/10/2018
ms.locfileid: "42447786"
---
# <a name="how-queries-work"></a>クエリのしくみ

Entity Framework Core では統合言語クエリ (LINQ) を使用し、データベースにデータを問い合わせます。 LINQ では C# (あるいは自分で選んだ .NET 言語) を使用し、派生コンテキストとエンティティ クラスに基づいて、厳密に型指定されたクエリを記述できます。

## <a name="the-life-of-a-query"></a>クエリの全体像

各クエリが通過するプロセスの高次元での概要を次に示します。

1. LINQ クエリは、データベース プロバイダーで処理するために用意された表現をビルドするために、Entity Framework Core によって処理されます。
   1. クエリが実行されるたびにこの処理が実行される必要がないように、結果はキャッシュされます。
2. 結果が、データベース プロバイダーに渡されます。
   1. データベース プロバイダーは、クエリのどの部分がデータベースで評価できるかを識別します。
   2. クエリのこれらの部分は、データベース固有のクエリ言語 (リレーショナル データベースの SQL など) に変換されます。
   3. 1 つまたは複数のクエリがデータべースに送信され、結果セットが返されます (結果は、エンティティ インスタンスではなく、データベースからの値です)。
3. 結果セット内の各項目で、
   1. これが追跡クエリの場合、EF では、データがコンテキスト インスタンスの変更追跡に既にあるエンティティを表しているかどうかをチェックします。
      * 既にある場合、既存のエンティティが返されます。
      * ない場合、新しいエンティティが作成され、変更追跡が設定されて、新しいエンティティが返されます。
   2. これが追跡なしのクエリの場合、EF では、データがこのクエリの結果セットに既にあるエンティティを表しているかどうかをチェックします。
      * 既にある場合、既存のエンティティが返されます<sup>(1)</sup>。
      * ない場合、新しいエンティティが作成されて、返されます。

<sup>(1)</sup> 既に返されたエンティティの追跡を継続するために、追跡なしクエリでは弱参照を使用します。 同じ ID の前の結果が範囲外になっている場合は、ガベージ コレクションが実行され、新しいエンティティ インスタンスを取得できます。

## <a name="when-queries-are-executed"></a>クエリの実行時

LINQ 演算子を呼び出すと、単純にクエリのメモリ内表現がビルドされます。 クエリは、結果が使用されるときにデータベースに送信されるだけです。

クエリでの結果がデータベースに送信される最も一般的な操作は、次のとおりです。
* `for` ループ内で結果を反復処理する
* `ToList`、`ToArray`、`Single`、`Count` などの演算子を使用する
* クエリの結果を UI にデータバインドする

> [!WARNING]  
> **ユーザー入力を常に検証する:** EF が SQL インジェクション攻撃からの保護を提供している間は、一般的な入力の検証はまったく行われません。 そのため、値が API に渡される、LINQ クエリで使用される、エンティティ プロパティに割り当てられるなどの場合に、それらの値が信頼されていないソースに由来していると、アプリケーションの要件ごとに適切な検証が実行される必要があります。 これには、動的にクエリを構築する際に使用されるユーザー入力も含まれます。 LINQ を使用している場合であっても、式をビルドするためのユーザー入力を許可しているなら、目的の式だけは構築できることを確認する必要があります。
