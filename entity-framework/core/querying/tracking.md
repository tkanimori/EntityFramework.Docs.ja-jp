---
title: 追跡と追跡なしのクエリ - EF Core
description: Entity Framework Core の追跡クエリと非追跡クエリに関する情報
author: smitpatel
ms.date: 11/09/2020
uid: core/querying/tracking
ms.openlocfilehash: b4c059f9a9b726697009589271e007bd1d2afd56
ms.sourcegitcommit: f3512e3a98e685a3ba409c1d0157ce85cc390cf4
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/10/2020
ms.locfileid: "94430444"
---
# <a name="tracking-vs-no-tracking-queries"></a><span data-ttu-id="da72f-103">追跡と追跡なしのクエリ</span><span class="sxs-lookup"><span data-stu-id="da72f-103">Tracking vs. No-Tracking Queries</span></span>

<span data-ttu-id="da72f-104">Entity Framework Core によってその変更トラッカー内のエンティティ インスタンスに関する情報が保持されるかどうかは、追跡動作によって制御されます。</span><span class="sxs-lookup"><span data-stu-id="da72f-104">Tracking behavior controls if Entity Framework Core will keep information about an entity instance in its change tracker.</span></span> <span data-ttu-id="da72f-105">エンティティが追跡されている場合、エンティティ内で検出された変更はすべて、`SaveChanges()` の間にデータベースに対して永続化されます。</span><span class="sxs-lookup"><span data-stu-id="da72f-105">If an entity is tracked, any changes detected in the entity will be persisted to the database during `SaveChanges()`.</span></span> <span data-ttu-id="da72f-106">また、EF Core により、追跡クエリの結果内のエンティティ、および変更トラッカーに含まれるエンティティの間のナビゲーション プロパティも修正されます。</span><span class="sxs-lookup"><span data-stu-id="da72f-106">EF Core will also fix up navigation properties between the entities in a tracking query result and the entities that are in the change tracker.</span></span>

> [!NOTE]
> <span data-ttu-id="da72f-107">[キーなしエンティティ型](xref:core/modeling/keyless-entity-types)は追跡されません。</span><span class="sxs-lookup"><span data-stu-id="da72f-107">[Keyless entity types](xref:core/modeling/keyless-entity-types) are never tracked.</span></span> <span data-ttu-id="da72f-108">この記事でエンティティ型に関する言及がある場合は、必ずキーが定義されているエンティティ型を参照しています。</span><span class="sxs-lookup"><span data-stu-id="da72f-108">Wherever this article mentions entity types, it refers to entity types which have a key defined.</span></span>

> [!TIP]  
> <span data-ttu-id="da72f-109">この記事の[サンプル](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Querying/Tracking)は GitHub で確認できます。</span><span class="sxs-lookup"><span data-stu-id="da72f-109">You can view this article's [sample](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Querying/Tracking) on GitHub.</span></span>

## <a name="tracking-queries"></a><span data-ttu-id="da72f-110">追跡クエリ</span><span class="sxs-lookup"><span data-stu-id="da72f-110">Tracking queries</span></span>

<span data-ttu-id="da72f-111">既定では、エンティティ型を返すクエリは、追跡を行います。</span><span class="sxs-lookup"><span data-stu-id="da72f-111">By default, queries that return entity types are tracking.</span></span> <span data-ttu-id="da72f-112">つまり、それらのエンティティ インスタンスに変更を加え、`SaveChanges()` によってその変更を永続化させることができます。</span><span class="sxs-lookup"><span data-stu-id="da72f-112">Which means you can make changes to those entity instances and have those changes persisted by `SaveChanges()`.</span></span> <span data-ttu-id="da72f-113">次の例では、ブログ評価に対する変更が検出され、`SaveChanges()` の間にデータベースに対して永続化されています。</span><span class="sxs-lookup"><span data-stu-id="da72f-113">In the following example, the change to the blogs rating will be detected and persisted to the database during `SaveChanges()`.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#Tracking)]

<span data-ttu-id="da72f-114">追跡クエリで結果が返されると、EF Core で、エンティティが既にコンテキスト内に存在するかどうかがチェックされます。</span><span class="sxs-lookup"><span data-stu-id="da72f-114">When the results are returned in a tracking query, EF Core will check if the entity is already in the context.</span></span> <span data-ttu-id="da72f-115">EF Core で既存のエンティティが検出された場合は、同じインスタンスが返されます。</span><span class="sxs-lookup"><span data-stu-id="da72f-115">If EF Core finds an existing entity, then the same instance is returned.</span></span> <span data-ttu-id="da72f-116">EF Core では、エントリ内にあるエンティティのプロパティの現在の値と元の値がデータベースの値で上書きされません。</span><span class="sxs-lookup"><span data-stu-id="da72f-116">EF Core won't overwrite current and original values of the entity's properties in the entry with the database values.</span></span> <span data-ttu-id="da72f-117">エンティティがコンテキスト内に見つからない場合は、EF Core で新しいエンティティ インスタンスが作成され、コンテキストにアタッチされます。</span><span class="sxs-lookup"><span data-stu-id="da72f-117">If the entity isn't found in the context, then EF Core will create new entity instance and attach it to the context.</span></span> <span data-ttu-id="da72f-118">クエリ結果には、エンティティが含まれません。エンティティはコンテキストに追加されますが、まだデータベースには保存されていません。</span><span class="sxs-lookup"><span data-stu-id="da72f-118">Query results don't contain any entity, which is added to the context but not yet saved to the database.</span></span>

## <a name="no-tracking-queries"></a><span data-ttu-id="da72f-119">追跡なしのクエリ</span><span class="sxs-lookup"><span data-stu-id="da72f-119">No-tracking queries</span></span>

<span data-ttu-id="da72f-120">追跡なしのクエリは、読み取り専用のシナリオで結果が使用される場合に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="da72f-120">No tracking queries are useful when the results are used in a read-only scenario.</span></span> <span data-ttu-id="da72f-121">これらは、変更の追跡情報を設定する必要がないため、より高速に実行できます。</span><span class="sxs-lookup"><span data-stu-id="da72f-121">They're quicker to execute because there's no need to set up the change tracking information.</span></span> <span data-ttu-id="da72f-122">データベースから取得されたエンティティを更新する必要がない場合は、追跡なしのクエリを使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="da72f-122">If you don't need to update the entities retrieved from the database, then a no-tracking query should be used.</span></span> <span data-ttu-id="da72f-123">個別のクエリをスワップして、追跡なしにできます。</span><span class="sxs-lookup"><span data-stu-id="da72f-123">You can swap an individual query to be no-tracking.</span></span> <span data-ttu-id="da72f-124">追跡なしのクエリでは、ローカルの変更や追加されたエンティティとは関係なく、データベースの内容に基づいた結果も取得されます。</span><span class="sxs-lookup"><span data-stu-id="da72f-124">No tracking query will also give you results based on what is in the database disregarding any local changes or added entities.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#NoTracking)]

<span data-ttu-id="da72f-125">また、コンテキスト インスタンスのレベルで、既定の追跡動作を変更できます。</span><span class="sxs-lookup"><span data-stu-id="da72f-125">You can also change the default tracking behavior at the context instance level:</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#ContextDefaultTrackingBehavior)]

## <a name="identity-resolution"></a><span data-ttu-id="da72f-126">識別子の解決</span><span class="sxs-lookup"><span data-stu-id="da72f-126">Identity resolution</span></span>

<span data-ttu-id="da72f-127">追跡クエリでは変更トラッカーが使用されます。そのため、EF Core では追跡クエリで ID 解決が実行されます。</span><span class="sxs-lookup"><span data-stu-id="da72f-127">Since a tracking query uses the change tracker, EF Core will do identity resolution in a tracking query.</span></span> <span data-ttu-id="da72f-128">エンティティを具体化するとき、それが既に追跡されている場合は、EF Core によって変更トラッカーから同じエンティティ インスタンスが返されます。</span><span class="sxs-lookup"><span data-stu-id="da72f-128">When materializing an entity, EF Core will return the same entity instance from the change tracker if it's already being tracked.</span></span> <span data-ttu-id="da72f-129">結果に同じエンティティが複数回含まれている場合は、そのたびに同じインスタンスが返されます。</span><span class="sxs-lookup"><span data-stu-id="da72f-129">If the result contains same entity multiple times, you get back same instance for each occurrence.</span></span> <span data-ttu-id="da72f-130">追跡なしのクエリでは変更トラッカーが使用されず、ID 解決は実行されません。</span><span class="sxs-lookup"><span data-stu-id="da72f-130">No-tracking queries don't use the change tracker and don't do identity resolution.</span></span> <span data-ttu-id="da72f-131">そのため、同じエンティティが結果に複数回含まれている場合でも、エンティティの新しいインスタンスが返されます。</span><span class="sxs-lookup"><span data-stu-id="da72f-131">So you get back new instance of entity even when the same entity is contained in the result multiple times.</span></span> <span data-ttu-id="da72f-132">この動作は、EF Core 3.0 以前のバージョンでは異なります (「[以前のバージョン](#previous-versions)」を参照)。</span><span class="sxs-lookup"><span data-stu-id="da72f-132">This behavior was different in versions before EF Core 3.0, see [previous versions](#previous-versions).</span></span>

<span data-ttu-id="da72f-133">EF Core 5.0 以降では、同じクエリで上記の両方の動作を組み合わせることができます。</span><span class="sxs-lookup"><span data-stu-id="da72f-133">Starting with EF Core 5.0, you can combine both of the above behaviors in same query.</span></span> <span data-ttu-id="da72f-134">つまり、追跡なしのクエリを使用できます。これにより、結果で ID 解決が行われます。</span><span class="sxs-lookup"><span data-stu-id="da72f-134">That is, you can have a no tracking query, which will do identity resolution in the results.</span></span> <span data-ttu-id="da72f-135">クエリ可能な `AsNoTracking()` 演算子と同じように、別の `AsNoTrackingWithIdentityResolution()` 演算子が追加されました。</span><span class="sxs-lookup"><span data-stu-id="da72f-135">Just like `AsNoTracking()` queryable operator, we've added another operator `AsNoTrackingWithIdentityResolution()`.</span></span> <span data-ttu-id="da72f-136"><xref:Microsoft.EntityFrameworkCore.QueryTrackingBehavior> 列挙型にも、関連するエントリが追加されています。</span><span class="sxs-lookup"><span data-stu-id="da72f-136">There's also associated entry added in <xref:Microsoft.EntityFrameworkCore.QueryTrackingBehavior> enum.</span></span> <span data-ttu-id="da72f-137">追跡なしで ID 解決を使用するようにクエリを構成すると、クエリ結果の生成時に、スタンドアロンの変更トラッカーがバックグラウンドで使用されます。そのため、各インスタンスが 1 回だけ具体化されます。</span><span class="sxs-lookup"><span data-stu-id="da72f-137">When you configure the query to use identity resolution with no tracking, we use a stand-alone change tracker in the background when generating query results so each instance is materialized only once.</span></span> <span data-ttu-id="da72f-138">この変更トラッカーはコンテキスト内のものとは異なるため、結果はコンテキストによって追跡されません。</span><span class="sxs-lookup"><span data-stu-id="da72f-138">Since this change tracker is different from the one in the context, the results are not tracked by the context.</span></span> <span data-ttu-id="da72f-139">クエリが完全に列挙されると、変更トラッカーはスコープ外になり、必要に応じてガベージ コレクションが実行されます。</span><span class="sxs-lookup"><span data-stu-id="da72f-139">After the query is enumerated fully, the change tracker goes out of scope and garbage collected as required.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#NoTrackingWithIdentityResolution)]

## <a name="tracking-and-custom-projections"></a><span data-ttu-id="da72f-140">追跡とカスタム プロジェクション</span><span class="sxs-lookup"><span data-stu-id="da72f-140">Tracking and custom projections</span></span>

<span data-ttu-id="da72f-141">クエリの結果の型がエンティティ型ではない場合でも、EF Core では既定で、結果に含まれているエンティティ型が引き続き追跡されます。</span><span class="sxs-lookup"><span data-stu-id="da72f-141">Even if the result type of the query isn't an entity type, EF Core will still track entity types contained in the result by default.</span></span> <span data-ttu-id="da72f-142">次のクエリでは、匿名の型が返され、結果セット内で `Blog` のインスタンスが追跡されます。</span><span class="sxs-lookup"><span data-stu-id="da72f-142">In the following query, which returns an anonymous type, the instances of `Blog` in the result set will be tracked.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#CustomProjection1)]

<span data-ttu-id="da72f-143">結果セットに LINQ の合成に由来するエンティティ型が含まれていた場合は、EF Core によってそれらが追跡されます。</span><span class="sxs-lookup"><span data-stu-id="da72f-143">If the result set contains entity types coming out from LINQ composition, EF Core will track them.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#CustomProjection2)]

<span data-ttu-id="da72f-144">結果セットにいかなるエンティティ型も含まれていなかった場合は、追跡なしが実行されます。</span><span class="sxs-lookup"><span data-stu-id="da72f-144">If the result set doesn't contain any entity types, then no tracking is done.</span></span> <span data-ttu-id="da72f-145">次のクエリでは、エンティティの値の一部を含む (ただし実際のエンティティ型のインスタンスは含まない) 匿名型が返されます。</span><span class="sxs-lookup"><span data-stu-id="da72f-145">In the following query, we return an anonymous type with some of the values from the entity (but no instances of the actual entity type).</span></span> <span data-ttu-id="da72f-146">クエリから生じた追跡対象のエンティティはありません。</span><span class="sxs-lookup"><span data-stu-id="da72f-146">There are no tracked entities coming out of the query.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#CustomProjection3)]

 <span data-ttu-id="da72f-147">EF Core では、最上位レベルのプロジェクションでクライアント評価を行うことができます。</span><span class="sxs-lookup"><span data-stu-id="da72f-147">EF Core supports doing client evaluation in the top-level projection.</span></span> <span data-ttu-id="da72f-148">クライアント評価のために、EF Core によりエンティティ インスタンスが具体化された場合、それは追跡されます。</span><span class="sxs-lookup"><span data-stu-id="da72f-148">If EF Core materializes an entity instance for client evaluation, it will be tracked.</span></span> <span data-ttu-id="da72f-149">ここでは、`blog` エンティティがクライアント メソッド `StandardizeURL` に渡されているため、EF Core によって blog インスタンスも追跡されます。</span><span class="sxs-lookup"><span data-stu-id="da72f-149">Here, since we're passing `blog` entities to the client method `StandardizeURL`, EF Core will track the blog instances too.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#ClientProjection)]

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#ClientMethod)]

<span data-ttu-id="da72f-150">EF Core では、結果に含まれているキーなしのエンティティ インスタンスは追跡されません。</span><span class="sxs-lookup"><span data-stu-id="da72f-150">EF Core doesn't track the keyless entity instances contained in the result.</span></span> <span data-ttu-id="da72f-151">ただし、キーを持つその他のすべてのエンティティ型のインスタンスは、上記のルールに従って、EF Core によって追跡されます。</span><span class="sxs-lookup"><span data-stu-id="da72f-151">But EF Core tracks all the other instances of entity types with key according to rules above.</span></span>

<span data-ttu-id="da72f-152">上記のルールの一部は、EF Core 3.0 以前では異なった動作をします。</span><span class="sxs-lookup"><span data-stu-id="da72f-152">Some of the above rules worked differently before EF Core 3.0.</span></span> <span data-ttu-id="da72f-153">詳細については、「[以前のバージョン](#previous-versions)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="da72f-153">For more information, see [previous versions](#previous-versions).</span></span>

## <a name="previous-versions"></a><span data-ttu-id="da72f-154">以前のバージョン</span><span class="sxs-lookup"><span data-stu-id="da72f-154">Previous versions</span></span>

<span data-ttu-id="da72f-155">バージョン 3.0 より前の EF Core では、追跡の実行方法にいくつかの違いがありました。</span><span class="sxs-lookup"><span data-stu-id="da72f-155">Before version 3.0, EF Core had some differences in how tracking was done.</span></span> <span data-ttu-id="da72f-156">注意すべき違いは次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="da72f-156">Notable differences are as follows:</span></span>

- <span data-ttu-id="da72f-157">「[クライアントとサーバーの評価](xref:core/querying/client-eval)」ページで説明されているように、バージョン 3.0 より前の EF Core では、クエリのあらゆる部分でのクライアント評価がサポートされていました。</span><span class="sxs-lookup"><span data-stu-id="da72f-157">As explained in [Client vs Server Evaluation](xref:core/querying/client-eval) page, EF Core supported client evaluation in any part of the query before version 3.0.</span></span> <span data-ttu-id="da72f-158">クライアント評価によってエンティティの具体化が発生し、それは結果に含まれていませんでした。</span><span class="sxs-lookup"><span data-stu-id="da72f-158">Client evaluation caused materialization of entities, which weren't part of the result.</span></span> <span data-ttu-id="da72f-159">そのため、EF Core では、追跡対象を検出するために、その結果が分析されていました。この設計には、次のようないくつかの相違点があります。</span><span class="sxs-lookup"><span data-stu-id="da72f-159">So EF Core analyzed the result to detect what to track. This design had certain differences as follows:</span></span>
  - <span data-ttu-id="da72f-160">プロジェクションでのクライアント評価は、具体化を発生させましたが、具体化されたエンティティ インスタンスは返されず、追跡されませんでした。</span><span class="sxs-lookup"><span data-stu-id="da72f-160">Client evaluation in the projection, which caused materialization but didn't return the materialized entity instance wasn't tracked.</span></span> <span data-ttu-id="da72f-161">次の例では、`blog` エンティティが追跡されませんでした。</span><span class="sxs-lookup"><span data-stu-id="da72f-161">The following example didn't track `blog` entities.</span></span>
    [!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#ClientProjection)]

  - <span data-ttu-id="da72f-162">場合によっては、EF Core では LINQ の合成に由来するオブジェクトが追跡されませんでした。</span><span class="sxs-lookup"><span data-stu-id="da72f-162">EF Core didn't track the objects coming out of LINQ composition in certain cases.</span></span> <span data-ttu-id="da72f-163">次の例では、`Post` が追跡されませんでした。</span><span class="sxs-lookup"><span data-stu-id="da72f-163">The following example didn't track `Post`.</span></span>
    [!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#CustomProjection2)]

- <span data-ttu-id="da72f-164">クエリ結果にキーなしエンティティ型が含まれていた場合は、常にクエリ全体が追跡なしになりました。</span><span class="sxs-lookup"><span data-stu-id="da72f-164">Whenever query results contained keyless entity types, the whole query was made non-tracking.</span></span> <span data-ttu-id="da72f-165">つまり、結果に含まれている、キーを持つエンティティ型も追跡されませんでした。</span><span class="sxs-lookup"><span data-stu-id="da72f-165">That means that entity types with keys, which are in result weren't being tracked either.</span></span>
- <span data-ttu-id="da72f-166">EF Core により、追跡なしのクエリで ID 解決が実行されました。</span><span class="sxs-lookup"><span data-stu-id="da72f-166">EF Core did identity resolution in no-tracking query.</span></span> <span data-ttu-id="da72f-167">既に返されているエンティティを追跡するために、弱参照が使用されました。</span><span class="sxs-lookup"><span data-stu-id="da72f-167">It used weak references to keep track of entities that had already been returned.</span></span> <span data-ttu-id="da72f-168">そのため、結果セットに同じエンティティが複数回含まれていた場合は、そのたびに同じインスタンスが返されました。</span><span class="sxs-lookup"><span data-stu-id="da72f-168">So if a result set contained the same entity multiples times, you would get the same instance for each occurrence.</span></span> <span data-ttu-id="da72f-169">同じ ID を持つ前の結果がスコープから外れ、ガベージ コレクションが行われても、EF Core により新しいインスタンスが返されました。</span><span class="sxs-lookup"><span data-stu-id="da72f-169">Though if a previous result with the same identity went out of scope and got garbage collected, EF Core returned a new instance.</span></span>
