---
title: EF6 から EF Core へ移植 - EF
author: rowanmiller
ms.date: 10/27/2016
ms.assetid: 826b58bd-77b0-4bbc-bfcd-24d1ed3a8f38
uid: efcore-and-ef6/porting/index
ms.openlocfilehash: 77096b9bffba6b8c2a3d7bfb0c2e41e2d170a7db
ms.sourcegitcommit: 708b18520321c587b2046ad2ea9fa7c48aeebfe5
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/09/2019
ms.locfileid: "72182091"
---
# <a name="porting-from-ef6-to-ef-core"></a>EF6 から EF Core へ移植

EF Core には根本的な変更が加えられているため、変更するやむを得ない理由がない限り、EF6 アプリケーションの EF Core への移行はお勧めできません。
EF6 から EF Core への移行は、アップグレードではなく移植と考える必要があります。

> [!IMPORTANT]
> 移植プロセスを開始する前に、EF Core がご自身のアプリケーションのデータ アクセス要件を満たしていることを確認することが重要です。

## <a name="missing-features"></a>実装されていない機能

ご自身のアプリケーション内で使用する必要があるすべての機能が EF Core に含まれていることを確認します。 EF Core の機能セットと EF6 との詳細な比較については、[機能の比較](xref:efcore-and-ef6/index)に関するページをご覧ください。 必要な機能が不足している場合は、EF Core に移植する前に、それらの機能の不足を補正できることを確認してください。

## <a name="behavior-changes"></a>動作の変更

これは、EF6 と EF Core の間での動作に関する変更点の一覧です (すべてではありません)。 アプリケーションを移植する際に、これらの点に注意することが重要です。これらによってアプリケーションの動作方法が変更される可能性がありますが、EF Core へのスワップ後にコンパイル エラーとして表示されることはありません。

### <a name="dbsetaddattach-and-graph-behavior"></a>DbSet.Add/Attach とグラフの動作

EF6 では、エンティティに対して `DbSet.Add()` を呼び出すと、そのナビゲーション プロパティで参照されているすべてのエンティティに対して再帰的な検索が実行されます。 見つかったすべてのエンティティと、まだコンテキストによって追跡されていないエンティティも、追加済みとしてマークされます。 `DbSet.Attach()` の動作は、すべてのエンティティが変更なしとしてマークされる以外は同じです。

**EF Core でも同様の再帰的な検索が実行されますが、若干異なる規則がいくつか使われます。**

*  ルート エンティティは常に要求された状態になります (`DbSet.Add` の場合は追加済み、`DbSet.Attach` の場合は変更なし)。

*  **ナビゲーション プロパティの再帰的な検索中に検出されたエンティティの場合:**

    *  **エンティティの主キーがストアで生成されたものだった場合**

        * 主キーが値に設定されていない場合、状態は追加済みに設定されます。 主キーに対してそのプロパティの型の CLR 既定値 (たとえば、`int` に対して `0`、`string` に対して `null` など) が割り当てられていた場合、それは "未設定" と見なされます。

        * 主キーが値に設定されていた場合、その状態は変更なしに設定されます。

    *  主キーがデータベースで生成されたものではなかった場合、そのエンティティはルートと同じ状態になります。

### <a name="code-first-database-initialization"></a>Code First のデータベース初期化

**EF6 には、データベース接続の選択やデータベースの初期化に関連して実行される魔法が大量に含まれています。たとえば、次のような規則があります。**

* 構成が実行されない場合、EF6 により SQL Express または LocalDb のデータベースが選択されます。

* コンテキストと同じ名前の接続文字列がアプリケーションの `App/Web.config` ファイル内にある場合は、この接続が使用されます。

* データベースが存在しない場合は、作成されます。

* モデルのテーブルがデータベース内に 1 つも存在しない場合は、現在のモデルのスキーマがデータベースに追加されます。 移行が有効になっている場合、データベースを作成するためにそれらが使用されます。

* データベースが存在し、EF6 によって既にスキーマが作成されていた場合は、スキーマに現在のモデルとの互換性があるかどうかがチェックされます。 スキーマの作成後にモデルが変更されていた場合は、例外がスローされます。

**EF Core では、このような魔法は実行されません。**

* データベース接続は、コード内で明示的に構成する必要があります。

* 初期化は実行されません。 `DbContext.Database.Migrate()` を使って移行を適用する必要があります (または、`DbContext.Database.EnsureCreated()` および `EnsureDeleted()` を使って、移行を使わずにデータベースの作成/削除を行います)。

### <a name="code-first-table-naming-convention"></a>Code First のテーブルの名前付け規則

EF6 では、エンティティ クラス名を複数形化サービスにかけて、そのエンティティがマップされる既定のテーブル名を計算します。

EF Core では、派生コンテキストでエンティティが公開される `DbSet` プロパティの名前が使われます。 エンティティに `DbSet` プロパティがない場合は、クラス名が使われます。
